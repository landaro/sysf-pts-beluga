\documentclass[a4paper,UKenglish]{lipics-v2016}

\usepackage{microtype}%if unwanted, comment out or use option "draft"

% custom packages
\usepackage{mathpartir}
\usepackage{xspace}
\usepackage{etoolbox}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{empheq}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% For having two versions of a paper in one file.
% Stuff that does not fit into the short version can be encosed in \LONGVERSION{...}

\ifdefined\LONGVERSION
  \relax
\else
% short version:
 \newcommand{\LONGVERSION}[1]{}
 \newcommand{\SHORTVERSION}[1]{#1}
% % long version:
% \newcommand{\LONGVERSION}[1]{#1}
% \newcommand{\SHORTVERSION}[1]{}
%\newcommand{\SHORTVERSION}[1]{BEGIN~SHORT\ #1 \ END~SHORT}
\fi
\newcommand{\LONGSHORT}[2]{\LONGVERSION{#1}\SHORTVERSION{#2}}

\renewcommand{\TirNameStyle}[1]{\small \textsf{#1}}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Relating System F and $\lambda$2: A Case Study in Coq, Abella and Beluga}
\titlerunning{Relating System F and $\lambda2$}

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Jonas Kaiser}
\author[2]{Brigitte Pientka}
\author[3]{Gert Smolka}
\affil[1]{Saarland University, Saarbrücken, Germany\\
  \texttt{jkaiser@ps.uni-saarland.de}}
\affil[2]{School of Computer Science, Montreal, Canada\\
  \texttt{bpientka@cs.mcgill.ca}}
\affil[3]{Saarland University, Saarbrücken, Germany\\
  \texttt{smolka@ps.uni-saarland.de}}
\authorrunning{J. Kaiser, B. Pientka and G. Smolka} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Jonas Kaiser, Brigitte Pientka and Gert Smolka}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{F.4.1 Mathematical Logic -- Lambda calculus and related systems}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation".
\keywords{Pure Type Systems, System F, de Bruijn Syntax, Higher-Order Abstract Syntax, Contextual Reasoning}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{2nd International Conference on Formal Structures for Computation and Deduction (FSCD 2017)}
\EventShortTitle{FSCD 2017}
\EventAcronym{FSCD}
\EventYear{2017}
\EventDate{September 3--9, 2017}
\EventLocation{Oxford, United Kingdom}
\EventLogo{}
\SeriesVolume{2}
\ArticleNo{XY}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% Content macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% uniform meta space
\newcommand{\ms}{\,}
\newcommand{\mrel}[1]{\mathrel{\ms #1 \ms}}

% Meta-Level Propositions
\newcommand{\Prop}{\ensuremath{\mathsf{PROP}}}
\newcommand{\Nat}{\mathbb{N}}

% Meta-level Symbols and Operators
\newcommand{\dom}[1]{\ensuremath{\textrm{dom$\,#1$}}}
\newcommand{\OF}{\mrel{:}}
\newcommand{\mOr}{\mrel{\vee}}
\newcommand{\mAnd}{\mrel{\wedge}}
\newcommand{\mAll}[1]{\ensuremath{\forall} #1.\ms\ms}
\newcommand{\mEx}[1]{\ensuremath{\exists} #1.\ms\ms}
\newcommand{\mExu}[1]{\ensuremath{\exists!} #1.\ms\ms}
\newcommand{\bnfdef}{\mrel{::=}}
\newcommand{\eqdef}{\mrel{:=}}
\newcommand{\set}[1]{\ensuremath{\{#1\}}}

\newcommand{\SysL}{$\lambda$2\xspace}


% Syntactic sorts of the object languages
\newcommand{\TyF}{\ensuremath{\mathsf{Ty_{F}}}}
\newcommand{\TmF}{\ensuremath{\mathsf{Tm_{F}}}}
\newcommand{\TmL}{\ensuremath{\mathsf{Tm_{\lambda}}}}

\newcommand{\TyCtxF}{\ensuremath{\mathsf{C_{F}^{ty}}}}
\newcommand{\TmCtxF}{\ensuremath{\mathsf{C_{F}^{tm}}}}
\newcommand{\CtxL}{\ensuremath{\mathsf{C_{\lambda}}}}
\newcommand{\TyCtxR}{\ensuremath{\mathsf{C_{R}^{ty}}}}
\newcommand{\TmCtxR}{\ensuremath{\mathsf{C_{R}^{tm}}}}


% Generic type-system judgement predicates
\newcommand{\istyFpr}{\ensuremath{\mathsf{isty_{F}}}}
\newcommand{\typingFpr}{\ensuremath{\mathsf{ofty_{F}}}}
\newcommand{\typingLpr}{\ensuremath{\mathsf{ofty_{\lambda}}}}

% Judgements
\newcommand{\ty}{\mathsf{ty}}
\newcommand{\tm}{\mathsf{tm}}
\newcommand{\of}{\ensuremath{\!:\!}}
\newcommand{\cc}[2]{#1;#2} % compound System F contexts
\makeatletter
\newcommand{\raisemath}[1]{\mathpalette{\raisem@th{#1}}}
\newcommand{\raisem@th}[3]{\raisebox{#1}{\ensuremath{#2#3}}}
\makeatother
\newcommand{\tsAnnot}[2]{\vdash\hspace{-.7em}^{\raisemath{1.5pt}{\scriptscriptstyle{#2}}}_{\raisemath{0.3pt}{\scriptscriptstyle{#1}}}} % note: wrap instances in \mathbin
\newcommand{\cts}[2]{\ensuremath{(\,#1 #2 {})}} % context + turnstile for CMs
\newcommand{\tfF}{\tsAnnot{\mathsf{F}}{\ty}}  % for type formation judgement
\newcommand{\tyF}{\tsAnnot{\mathsf{F}}{\tm}}  % for typing judgement
\newcommand{\istyF}[2]{\ensuremath{{#1} \mathrel{\tfF} #2}}
\newcommand{\typingF}[3]{\ensuremath{{#1} \mathrel{\tyF} #2 \OF #3}}
\newcommand{\tyL}{\tsAnnot{\lambda}{}} % for typing judgement
\newcommand{\typingL}[3]{\ensuremath{{#1} \mathrel{\tyL} #2 \OF #3}}
\newcommand{\inL}{\mrel{\in_{\lambda}}}
\newcommand{\tfP}{\tsAnnot{\mathsf{P}}{\ty}}  % for type formation judgement
\newcommand{\istyFh}[1]{\ensuremath{#1\ms\mathsf{ty}}}
\newcommand{\typingFh}[2]{\ensuremath{#1 \mathbin{:_{F}} #2}}
\newcommand{\sortLh}[1]{\ensuremath{\mathcal{U}\ms#1}}
\newcommand{\typingLh}[2]{\ensuremath{#1 \mathbin{:_{\lambda}} #2}}


% The type and term relations
\newcommand{\tyr}{\mathrel{\sim}}
\newcommand{\tmr}{\mathrel{\approx}}

\newcommand{\Rext}[1]{\ensuremath{#1^{\mathsf{ext}}}}
\newcommand{\Rshift}[1]{\ensuremath{#1^{\Uparrow}}}

% relational context morphisms
\newcommand{\tyctxrelFL}[3]{\ensuremath{#1\mathrel{\mathop{\longrightarrow}^{#2}\limits}#3}}
\newcommand{\tyctxrelLF}[3]{\ensuremath{#1\mathrel{\mathop{\longleftarrow}^{#2}\limits}#3}}
\newcommand{\tmctxrelFL}[4]{\ensuremath{#1\mathrel{\mathop{\longrightarrow}^{#2}_{#3}\limits}#4}}
\newcommand{\tmctxrelLF}[4]{\ensuremath{#1\mathrel{\mathop{\longleftarrow}^{#2}_{#3}\limits}#4}}

% L-Prolog syntax
\newcommand{\lpPi}[1]{\mathbf{\Pi} #1.\ms\ms}
\newcommand{\lpApp}[2]{#1\langle#2\rangle}
\newcommand{\lpImp}{\mrel{=\!\blacktriangleright}}

% Object Syntax
\newcommand{\Prp}{\ensuremath{\textrm{\textasteriskcentered}}}
\newcommand{\Typ}{\ensuremath{\square}}
\newcommand{\All}{\ensuremath{\forall.\,}}
\newcommand{\nAll}[1]{\ensuremath{\forall #1.\,}}
\newcommand{\Lam}[1]{\ensuremath{\lambda #1.\,}}
\newcommand{\TyLam}{\ensuremath{\Lambda.\,}}
\newcommand{\nTyLam}[1]{\ensuremath{\Lambda #1.\,}}
\newcommand{\Prod}[1]{\ensuremath{\Pi #1.\,}}

\newcommand{\emptyctx}{\ensuremath{\bullet}}

% Substitutions
\newcommand{\subst}[1]{\hphantom{|}\!\![{#1}]}
\newcommand{\scons}{\mathbin{\hspace{0.05em}\cdot\hspace{0.05em}}}
\newcommand{\scomp}{\mathbin{\hspace{-0.1em}{\circ}\hspace{-0.1em}}}
\newcommand{\hscomp}{\mathbin{\hspace{-0.1em}{\hat\circ}\hspace{-0.1em}}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\up}{{\Uparrow}}
%\newcommand{\shift}{\ensuremath{\hspace{0.06em}\textsf{\small +}\!1\hspace{-0.06em}}}
%\newcommand{\ushift}{\ensuremath{\textsf{\small -}\!1}}
\newcommand{\shift}{\ensuremath{\hspace{0.1em}\mathsf{+}\hspace{0.08em}\!1}}
\newcommand{\ushift}{\ensuremath{\hspace{0.1em}\textsf{--}\hspace{0.1em}\!1}}

% Facts without proof
\theoremstyle{plain}
\newtheorem{fact}[theorem]{Fact}
%\AtEndEnvironment{fact}{\null\hfill\qedsymbol}%

%%% Content macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle
%\raggedbottom

\begin{abstract}
  We give three formalisations of a proof of the equivalence of the usual, two-sorted presentation of System~F and its single-sorted pure type system (PTS) variant \SysL.
  This is established by reducing the typability problem of F to \SysL and vice versa.
  A key challenge is the treatment of variable binding and contextual information.
  The formalisations all share the same high level proof structure using relations to connect the type systems.
  They do, however, differ significantly in their representation and manipulation of variables and contextual information.
  In Coq, we use pure de~Bruijn indices and parallel substitutions.
  In Abella, we use higher-order abstract syntax (HOAS) and nominal constants of the ambient reasoning logic.
  In Beluga, we also use HOAS but within contextual modal type theory.
  Our contribution is twofold.
  First, we present and compare a collection of machine-checked solutions to a non-trivial theoretical result.
  Second, we propose our proof as a benchmark, complementing the POPLmark and ORBI challenges by testing how well a given proof assistant or framework handles complex contextual information involving multiple type systems.
\end{abstract}

\section{Introduction}
\label{sec:intro}

\begin{figure}[t]
  \begin{center}
    \small
    \begin{align*}
      \Aboxed{\TyF} & A, B &\bnfdef X \mid A \to B \mid \nAll X A & \quad\qquad\Aboxed{\TmF} & s, t &\bnfdef x \mid s\,t \mid \Lam {x \of A} s \mid s\,A \mid \nTyLam X s\\
      \Aboxed{\TyCtxF} & \Delta &\bnfdef \emptyset \mid \Delta, X & \quad\qquad\Aboxed{\TmCtxF} & \Gamma &\bnfdef \emptyctx \mid \Gamma, x \of A
    \end{align*}
    \begin{mathpar}
      \inferrule*{X \in \Delta}{\istyF{\Delta}{X}} \and
      \inferrule*{\istyF{\Delta}{A} \\ \istyF{\Delta}{B}}{\istyF{\Delta}{A \to B}} \and
      \inferrule*[right=$X \notin \Delta$]{\istyF{\Delta,X}{A}}{\istyF{\Delta}{\nAll X A}} \and
      \inferrule*{\Gamma(x)=A \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{x}{A}} \\
      \inferrule*{\typingF{\cc{\Delta}{\Gamma}}{s}{A \to B} \\ \typingF{\cc{\Delta}{\Gamma}}{t}{A}}{\typingF{\cc{\Delta}{\Gamma}}{s\,t}{B}} \and
      \inferrule*[right=$x \notin \dom{\Gamma}$]{\typingF{\cc{\Delta}{\Gamma,x \of A}}{s}{B} \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{\Lam {x \of A} s}{A \to B}} \\
      \inferrule*{\typingF{\cc{\Delta}{\Gamma}}{s}{\nAll X B} \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{s\, A}{B\subst{A/X}}} \and
      \inferrule*[right=$X \notin \Delta$]{\typingF{\cc{\Delta, X}{\Gamma}}{s}{A}}{\typingF{\cc{\Delta}{\Gamma}}{\nTyLam X s}{\nAll X A}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{Stratified System~F: types, terms, contexts, type formation and typing.\vspace{-1em}}
  \label{fig:sys-f}
\end{figure}

\begin{figure}[t]
  \begin{center}
    \small
    \begin{align*}
      \Aboxed{\TmL} & a, b, c, d &\bnfdef \Prp \mid \Typ \mid x \mid a\,b \mid \Lam{x \of a} b \mid \Prod{x \of a} b & \qquad\qquad\Aboxed{\CtxL} & \Psi &\bnfdef \emptyctx \mid \Psi, x \of a
    \end{align*}
    \begin{mathpar}
      \mprset{sep=1.5em}
      \inferrule*{~}{\typingL{\Psi}{\Prp}{\Typ}} \and
      \inferrule*{x \of a \in \Psi \\ \typingL{\Psi}{a}{u}}{\typingL{\Psi}{x}{a}} \and
      \inferrule*[right=$x \notin \dom{\Psi}$]{\typingL{\Psi}{a}{u} \\ \typingL{\Psi,x \of a}{b}{\Prp}}{\typingL{\Psi}{\Prod{x \of a} b}{\Prp}} \\
      \inferrule*{\typingL{\Psi}{a}{\Prod{x \of c} d} \\ \typingL{\Psi}{b}{c}}{\typingL{\Psi}{a\, b}{d\subst{b/x}}} \and
      \inferrule*[right=$x \notin \dom{\Psi}$]{\typingL{\Psi}{a}{u} \\ \typingL{\Psi, x \of a}{b}{c} \\ \typingL{\Psi, x \of a}{c}{\Prp}}{\typingL{\Psi}{\Lam{x \of a} b}{\Prod{x \of a} c}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{PTS: terms, contexts, and the type system \SysL; $u$ ranges over the universes $\Prp$ and $\Typ$.\vspace{-1em}}
  \label{fig:sys-l}
\end{figure}

There are different presentations of ``System~F'' in the literature and they are effectively considered equivalent, which is used to justify the transport of theoretical results between said presentations.
The assumed notion of equivalence is primarily a reduction of the typability problem from one system to the other.
While the existence of a suitable correspondence between the systems may appear likely or obvious, it turns out that actually proving it formally is surprisingly intricate.
As long as the systems in question use the same expression syntax, the proofs are usually tedious but straightforward.
If, on the other hand, not only the type systems, but also the syntactic languages differ, then establishing the correct correspondence becomes much more involved.
The goal of this paper is to showcase various formalisation techniques to deal with the intricacies that arise in such an equivalence proof.

%\enlargethispage{\baselineskip}

System~F in its original form is due to Girard~\cite{Girard1972, Girard1989}, who introduced it in the context of proof theory.
It was also independently discovered by Reynolds~\cite{DBLP:conf/programm/Reynolds74} as the polymorphic $\lambda$-calculus.
For the purpose of this paper we consider two presentations that differ sufficiently to demonstrate the various complications.
The first, called F and shown in Fig.~\ref{fig:sys-f}, is the common two-sorted, or stratified, presentation, as for example given by Harper~\cite{Harper2013}.
The second, given in Fig.~\ref{fig:sys-l}, is the pure type system (PTS) \SysL, which appears as a corner in Barendregt's $\lambda$-cube~\cite{DBLP:journals/jfp/Barendregt91}.

In~\cite{Geuvers1993}, Geuvers gives a proof sketch that valid typing judgements can be translated between these two presentations.
In~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq} we then gave the first proof, machine-checked in Coq, of the full reduction result.
The proof presented here is a lot simpler for a number of reasons.
We use relations on the two syntactic languages rather than translation functions, so we do not have to concern ourselves with cancellation laws.
We can further establish the correspondence directly, which completely bypasses the need for an intermediate, stratified type system for the PTS syntax.

\begin{figure}[t]
  \begin{center}
    \small
    \begin{align*}
      \Aboxed{\TyCtxR} & \Theta &\bnfdef \emptyctx \mid \Theta, (X,y) & \qquad\qquad\Aboxed{\TmCtxR} &\Sigma &\bnfdef \emptyctx \mid \Sigma, (x,y)\hspace{6em}
    \end{align*}
    \begin{mathpar}
      \inferrule*{(X,y) \in \Theta}{\Theta \vdash X \tyr y} \and
      \inferrule*[right=$x \notin \Theta$]{\Theta \vdash A \tyr a \\ \Theta \vdash B \tyr b}{\Theta \vdash A \to B \tyr \Prod{y \of a} b} \and
      \inferrule*[right={$X,y \notin \Theta$}]{\Theta, (X,y) \vdash A \tyr a}{\Theta \vdash \nAll{X} A \tyr \Prod{y \of \Prp} a}\\
      \inferrule*{(x,y) \in \Sigma}{\cc{\Theta}{\Sigma} \vdash x \tmr y} \and
      \inferrule*{\cc{\Theta}{\Sigma} \vdash s \tmr a \\ \cc{\Theta}{\Sigma} \vdash t \tmr b}{\cc{\Theta}{\Sigma} \vdash s\,t \tmr a\,b} \and
      \inferrule*{\cc{\Theta}{\Sigma} \vdash s \tmr a \\ \Theta \vdash A \tyr b}{\cc{\Theta}{\Sigma} \vdash s\,A \tmr a\,b}\\
      \inferrule*[right={$x,y \notin \Theta,\Sigma$}]{\Theta \vdash A \tyr a \\ \cc{\Theta}{\Sigma, (x,y)} \vdash s \tmr b}{\cc{\Theta}{\Sigma} \vdash \Lam{x \of A} s \tmr \Lam{y \of a} b} \and
      \inferrule*[right={$X,y \notin \Theta,\Sigma$}]{\cc{\Theta, (X,y)}{\Sigma} \vdash s \tmr a}{\cc{\Theta}{\Sigma} \vdash \nTyLam{X} s \tmr \Lam{y \of \Prp} a}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{Inductive characterisation of $\tyr$ and $\tmr$; $\Theta$ and $\Sigma$ track related type and terms variables.\vspace{-1em}}
  \label{fig:rel}
\end{figure}

The relations that precisely establish the correspondence of our two systems are realised as inductive predicates (Fig.~\ref{fig:rel}).
The main advantage over the functional approach is that it allows us to focus on the meaningful, well-typed fragments of the two systems.
Despite these simplifications we still have to face the metaphorical elephant in the room, namely variable binding and context manipulation.
More precisely, we have to represent and handle contexts that track various kinds of information, like the set of defined variables, their associated types, their correspondence to other variables, and so on.
To make the situation fully explicit: our contexts are dependent sequences of dependent records.

In the following we present three formalisations.
They all follow the same basic proof structure, outlined in Sect.~\ref{sec:equi}, but they each deal with the complexities of contextual information and variable binding in different ways.
In Sects.~\ref{sec:coq},~\ref{sec:abella}~and~\ref{sec:beluga} we discuss in detail how this is managed in Coq~\cite{CoqWebsite}, Abella~\cite{AbellaTutorial} and respectively Beluga~\cite{Pientka:CADE15}.
The Coq proof employs pure de Bruijn syntax and parallel substitutions.
Meanwhile, both Abella and Beluga allow us to work with higher-order abstract syntax (HOAS), albeit in two rather different background logics.

While the comparison of proofs from different systems in terms of code lines is only marginally meaningful, we were surprised to find that all three developments each take approximately 500 loc, with Beluga slightly on the shorter side and Coq somewhat on the longer.
This, however, only covers establishing the correspondence itself.
The systems require vastly different amounts of code to establish the separate meta theories for the two discussed type systems, due to different levels of background support.

\noindent{\bf Contributions of the paper:}
\begin{enumerate}
\item We present and compare three different machine checked formalisations of the technically intricate reduction of typability from System~F to the PTS \SysL and vice versa.\footnote{The accompanying developments can be found at \url{https://www.ps.uni-saarland.de/extras/fscd17/}}
\item We propose that our equivalence proof serves as a benchmark for reasoning about and relating multiple type systems and languages involving variable binding.
  The key aspect of this benchmark is the representation and manipulation of contexts that track multiple kinds of information and exhibit complex dependency structures.
  As such it can be seen as a complement to the benchmarks proposed in~\cite{Felty:ITP10,Felty:orbi-survey} and the POPLmark challenge~\cite{poplmark}.
\end{enumerate}

\section{Equivalence}
\label{sec:equi}

The core challenge of the proof is the fact that F clearly distinguishes types and terms with separate syntactic sorts, $\TyF$ and $\TmF$ respectively, while \SysL merges these into a single syntactic sort $\TmL$.
The distinction still exists in \SysL but it is semantically imposed through the type system, rather than at the level of syntax.
Further consequences are the existence of two variable scopes in F, with separate abstraction and application mechanisms, while the same concepts are uniformly represented in \SysL for a single variable scope.
This extends to the formation of function spaces as well.
For an in-depth discussion of the mismatches between the two systems see~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}.
In essence the two systems differ in how explicit and readily available certain structural properties are.
One half of the proof will thus have to reestablish implicit structures, which, as one would expect, is harder than removing it.
This will lead to a certain asymmetry in proof effort for seemingly symmetrical lemma statements.

\enlargethispage{\baselineskip}

The basic idea of the proof presented here is to construct two relations $\tyr$ and $\tmr$ that put the types and respectively the terms of the two languages in correspondence (see Fig.~\ref{fig:rel}).
To obtain the desired equivalence results, we have to demonstrate that the relations exhibit the following properties:
\begin{enumerate}
  \item $\tyr$ is functional and injective.
  \item $\tyr$ is left-total and type-formation preserving on the well-formed types of F.
  \item $\tyr$ is right-total and type-formation preserving on the propositions of \SysL.
    A proposition of \SysL is any term $a \OF \TmL$ such that $\typingL{}{a}{\Prp}$ holds.
  \item $\tmr$ is functional and injective.
  \item $\tmr$ is left-total and typing preserving on the well-typed terms of F.
  \item $\tmr$ is right-total and typing preserving on the proofs of \SysL.
    A proof of \SysL is any term~${b \OF \TmL}$ such that $\typingL{}{b}{a}$ holds for $a$ a proposition of \SysL.
\end{enumerate}
We can now formulate, and easily prove, the following equivalences:

\begin{theorem}[Reductions from F to \SysL]
  \begin{align*}
    \istyF{}{A} &\iff \mExu{a} {} \vdash A \tyr a \mAnd \typingL{}{a}{\Prp}\\
    \typingF{}{s}{A} &\iff \mExu{b a} {} \vdash s \tmr b \mAnd {} \vdash A \tyr a \mAnd \typingL{}{b}{a} \mAnd \typingL{}{a}{\Prp}
  \end{align*}
\end{theorem}

\begin{proof}
  The forward directions are simply the corresponding left-to-right preservation and left-totality results of $\tmr$ and $\tyr$.
  Uniqueness follows from functionality.
  For the inverse direction we use preservation (here from right to left) and uniqueness.
\end{proof}

\begin{theorem}[Reductions from \SysL to F]
  \begin{align*}
    \typingL{}{a}{\Prp} &\iff \mExu{A} {} \vdash A \tyr a \mAnd \istyF{}{A}\\
    \typingL{}{b}{a} \mAnd \typingL{}{a}{\Prp} &\iff \mExu{s A} {} \vdash s \tmr b \mAnd {} \vdash A \tyr a \mAnd \typingF{}{s}{A}
  \end{align*}
\end{theorem}

\begin{proof}
  Dual to the previous result.
\end{proof}

For the remainder of the paper, we focus on how F, \SysL and the two relations $\tyr$ and $\tmr$ are represented in our three proof systems, and how the various properties of the relations are obtained.

\section{Coq}
\label{sec:coq}

\begin{figure}
  \begin{center}
    \small
    \begin{align*}
      A, B &\bnfdef x_\ty \mid A \to B \mid \All A & s, t &\bnfdef x_\tm \mid s\,t \mid \Lam A s \mid s\,A \mid \TyLam s & &x, N \OF \Nat
    \end{align*}
    \begin{mathpar}
      \mprset{andskip=1em,sep=1.1em}
      \inferrule*{x < N}{\istyF{N}{x_\ty}} \and
      \inferrule*{\istyF{N}{A} \\ \istyF{N}{B}}{\istyF{N}{A \to B}} \and
      \inferrule*{\istyF{N+1}{A}}{\istyF{N}{\All A}} \and
      \inferrule*{\Gamma_x = A \\ \istyF{N}{A}}{\typingF{\cc{N}{\Gamma}}{x_\tm}{A}} \and
      \inferrule*{\typingF{\cc{N}{\Gamma}}{s}{\All A} \\\istyF{N}{B}}{\typingF{\cc{N}{\Gamma}}{s\, B}{A\subst{B\scons\id}}} \and
      \inferrule*{\typingF{\cc{N+1}{\Gamma\subst{\shift}}}{s}{A}}{\typingF{\cc{N}{\Gamma}}{\TyLam s}{\All A}} \and
      \inferrule*{\typingF{\cc{N}{\Gamma,A}}{s}{B} \\ \istyF{N}{A}}{\typingF{\cc{N}{\Gamma}}{\Lam A s}{A \to B}} \and
      \inferrule*{\typingF{\cc{N}{\Gamma}}{s}{A \to B} \\ \typingF{\cc{N}{\Gamma}}{t}{A}}{\typingF{\cc{N}{\Gamma}}{s\,t}{B}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{System~F -- de Bruijn encoding in Coq; term variable contexts $\Gamma$ are lists of types.\vspace{-1em}}
  \label{fig:sys-f-coq}
\end{figure}

\begin{figure}
  \begin{center}
    \small
    \begin{align*}
      a, b, c, d &\bnfdef \Prp \mid \Typ \mid x \mid a\,b \mid \Lam a b \mid \Prod a b & &x \OF \Nat
    \end{align*}
    \begin{mathpar}
      \mprset{andskip=1.5em,sep=1.5em}
      \inferrule*{~}{0 \of a\subst{\shift} \inL \Psi,a}\and
      \inferrule*{x \of a \inL \Psi}{(x+1) \of a\subst{\shift} \inL \Psi,b}\and
      \inferrule*{~}{\typingL{\Psi}{\Prp}{\Typ}} \and
      \inferrule*{x \of a \inL \Psi \\ \typingL{\Psi}{a}{u}}{\typingL{\Psi}{x}{a}} \\
      \inferrule*{\typingL{\Psi}{a}{u} \\ \typingL{\Psi,a}{b}{\Prp}}{\typingL{\Psi}{\Prod a b}{\Prp}} \and
      \inferrule*{\typingL{\Psi}{a}{\Prod c d} \\ \typingL{\Psi}{b}{c}}{\typingL{\Psi}{a\, b}{d\subst{b\scons\id}}} \and
      \inferrule*{\typingL{\Psi}{a}{u} \\\\ \typingL{\Psi, a}{b}{c} \\ \typingL{\Psi, a}{c}{\Prp}}{\typingL{\Psi}{\Lam a b}{\Prod a c}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{\SysL{} -- de Bruijn encoding in Coq; dependent contexts $\Psi$ are lists of terms.\vspace{-1em}}
  \label{fig:sys-l-coq}
\end{figure}

\enlargethispage{\baselineskip}

For the Coq proof we reuse the pure de Bruijn encoding of the two systems and the corresponding language local meta theory developed in~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}, with major support from the Autosubst framework~\cite{DBLP:conf/itp/SchaferTS15}.
The language definitions are given in Figs.~\ref{fig:sys-f-coq}~and~\ref{fig:sys-l-coq}.
The main feature of de Bruijn syntax is the absence of variable names.
Variables are instead represented as numerical indices, where $n$ references the $n$th enclosing binder of the correct scope.
Dangling references represent free variables that instead reference positions in an enclosing context, indexed from right to left.
Note that we keep the dot around as a notational device to uniformly indicate the presence of a binding constructor, even if nothing remains to the left of it (e.g.\ $\TyLam s$).
It marks the precise spot where substitutions and indices have to be adjusted.
The application of a parallel substitution $\sigma$ to a term $s$ is written $s\subst{\sigma}$ where $\sigma$ is a function from $\Nat$ that acts on all free variables of $s$ at once.
The Autosubst framework provides a normalisation procedure for such terms with applied substitutions.
The existence of computable normal forms was demonstrated in~\cite{SchaeferEtAl:2009:Completeness}.
Context morphism lemmas (CML) are a useful proof device to reason about judgements over pure de Bruijn syntax.
In the following we will only focus on those aspects that have an immediate impact on our present proof.
For an in-depth discussion of the interaction of pure de Bruijn syntax, parallel substitutions and CMLs we refer to~\cite{deBruijn1972, SchaeferEtAl:2009:Completeness, DBLP:conf/itp/SchaferTS15, abadi1991, GoguenMcKinna1997, KaiserEtAl:2017:sysf_pts_equiv_coq}.

In the definition of F in Fig.~\ref{fig:sys-f-coq}, observe how the type variable context $\Delta$ degenerates to a plain natural number $N$.
It is taken as an exclusive upper bound to the admissible type variable indices, hence $N = 0$ represents the empty context.
The term variable context~$\Gamma$ is simply a list of types, since free variables are coded as context positions.
The \linebreak[0]$\beta$-substitution~$B\scons{\id}$ used in the type specialisation rule maps the free index 0 to $B$ and lowers all other indices by 1.

We further observe that for \SysL, defined in Fig.~\ref{fig:sys-l-coq}, context lookup is characterised inductively: $x \of a \inL \Psi$.
The need for this arises from the fact that the PTS contexts are dependent as well as the more general issue that in a de Bruijn setting, terms are not stable under context modifications.
Hence, upon extraction of a term $a$ from context $\Gamma$, all free variables of $a$ have to be adjusted by an amount that depends on the position of $a$ in $\Gamma$.
The given inductive characterisation elegantly handles this complication.

Let us now consider the first equivalence proof.
Similar to the way typing contexts are explicitly represented as lists of terms or types, we are going to track explicitly which variables are related in our definition of our relations $\tyr^R$ and $\tmr^R_S$, where the relational parameters $R$ and $S$ correspond to the contexts $\Theta$ and $\Sigma$ from Fig.~\ref{fig:rel}:

\vspace{-.5em}
{\small
\begin{mathpar}
  \mprset{andskip=1.5em,sep=1.5em}
  \inferrule*{x\,R\,y}{x_\ty\,\tyr^R\,y} \and
  \inferrule*{A\,\tyr^R\,a \\ B\,\tyr^{\Rshift{R}}\,b}{A \to B\,\tyr^R\,\Prod a b} \and
  \inferrule*{A\,\tyr^{\Rext{R}}\,a}{\All A\,\tyr^R\,\Prod \Prp a} \and
  \inferrule*{x\,S\,y}{x_\tm\,\tmr^R_S\,y} \\
  \inferrule*{s\,\tmr^R_S\,a \\ t\,\tmr^R_S\,b}{s\,t\,\tmr^R_S\,a\,b} \and
  \inferrule*{s\,\tmr^R_S\,a \\ A\,\tyr^R\,b}{s\,A\,\tmr^R_S\,a\,b} \and
  \inferrule*{A\,\tyr^R\,a \\ s\,\tmr^{\Rshift{R}}_{\Rext{S}}\,b}{\Lam A s\,\tmr^R_S\,\Lam a b} \and
  \inferrule*{s\,\tmr^{\Rext{R}}_{\Rshift{S}}\,a}{\TyLam s\,\tmr^R_S\,\Lam \Prp a}
\end{mathpar}
}\vspace{-1em}

The parameters $R$ and $S$ track pairs of indices of type, and respectively, term variables.
We technically represent them as lists of type $\mathsf{list}\,(\mathsf{var} \times \mathsf{var})$ and use $x\,R\,y$ to denote that the pair $(x,y)$ is in $R$.
The interesting part of this definition is how these auxiliary parameters have to be modified when binders are traversed, which we denoted above by $\Rshift{R}$ and $\Rext{R}$.
In order to precisely define these operations, let us recall the required action on a parallel substitution $\sigma$ that is pushed underneath a binder:
\begin{align*}
  (\All A)\subst{\sigma} \qquad\longmapsto\qquad \All A\subst{0 \scons \sigma \scomp \shift}
\end{align*}
The $\subst{0 \scons \_}$ part ensures that any index referencing the presently traversed binder is preserved as such.
Meanwhile the $\subst{\_ \scons \sigma \scomp \shift}$ part ensures that every index $n + 1$ is mapped to $\sigma(n)\subst{\shift}$, where the $\shift$ ensures that no free variables in the range of $\sigma$ are accidentally captured by the traversed binder.

In our correspondence proof we traverse binders \emph{almost} in lockstep.
For the simple cases where we have a binder on both sides of the relation, and moreover, the bound variables actually correspond according to the information tracked in $R$, we define, analogously to the binder traversal for substitutions:
\begin{align*}
  \Rext{R} \eqdef (0,0) \mathop{::} \mathsf{bimap}\,(\shift)\,(\shift)\,R
\end{align*}
where $\mathsf{bimap}\,f\,g\,R$ simply applies $f$ to all left projections of $R$ and $g$ to all right projections.

The other possible scenario has a binder on the \SysL side that has no counterpart in F with respect to the contextual information in $R$, like the \emph{not-really dependent} PTS product that corresponds to an arrow type in F.
As a consequence of this spurious binding, the \SysL indices in $R$ have to be shifted relative to their F counterparts.
This one-sided index adjustment is obtained with
\begin{align*}
  \Rshift{R} \eqdef \mathsf{bimap}\,\id\,(\shift)\,R
\end{align*}

\begin{fact}
  \label{fac:rel-ext}
  Both $\Rext{R}$ and $\Rshift{R}$ preserve injectivity and functionality of $R$.\hfill\qedsymbol
\end{fact}

\begin{lemma}
  \label{lem:tyr-inj-fun}
  The type relation $\tyr^R$ is injective/functional, whenever $R$ is injective/functional.
\end{lemma}
\begin{proof}
  Straightforward inductions using Fact~\ref{fac:rel-ext}.
\end{proof}

To obtain the same result for $\tmr^R_S$ we additionally rely on $R$ and $S$ having disjoint ranges, that is, no PTS variable is considered related to both a type and a term variable.
We denote this by $R \| S$.
\begin{fact}
  \label{fac:rel-disjoint}
  The property $R \| S$ is preserved under extending one relation and shifting the other, that is w.l.o.g.: $R \| S \implies \Rshift{R} \| \Rext{S}$.\hfill\qedsymbol
\end{fact}
\begin{lemma}
  \label{lem:rel-disjoint}
  Disjointedness of ranges lifts from variable relations $R$ and $S$ to $\tyr^R$ and $\tmr^R_S$:
  \begin{align*}
    R \| S \implies A \tyr^R a \implies s \tmr^R_S a \implies \bot
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $A \tyr^R a$ and discriminating on $s \tmr^R_S a$, using Fact~\ref{fac:rel-disjoint}.
\end{proof}
\begin{lemma}
  \label{lem:tmr-inj-fun}
  The term relation $\tmr^R_S$ is functional, whenever $R$ and $S$ are functional.
  It is injective, whenever $R$ and $S$ are injective and $R \| S$ holds.
\end{lemma}
\begin{proof}
  Straightforward inductions.
  Injectivity relies on the premise $R \| S$ and Lemma~\ref{lem:rel-disjoint} to discharge non-matching applications.
  Subderivations for $\tyr^R$ are handled with Lemma~\ref{lem:tyr-inj-fun}.
\end{proof}

Proving the left and right totality and preservation results is slightly more interesting, as we have to generalise to open judgements and non-empty contexts.
We achieve this with suitable proof invariants that are adapted from the notion of \emph{generalised context morphisms} laid out in~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}.
The key difference is that instead of a renaming $\xi$ that maps from one context to another, we here consider a relation on variables that places two contexts in correspondence.
All invariants are set up such that they vacuously hold when the initial context happens to be empty.
We start with type formation and the direction from F to \SysL:
\begin{align*}
  \tyctxrelFL{N}{R}{\Psi} \eqdef \mAll {x < N} \mEx y x\,R\,y \mAnd y \of \Prp \inL \Psi
\end{align*}
\begin{fact}
  \label{fac:inv-tyfl-ext}
  The invariant $\tyctxrelFL{N}{R}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tyctxrelFL{N}{R}{\Psi} \implies \tyctxrelFL{N}{\Rshift{R}}{\Psi,a} & &\tyctxrelFL{N}{R}{\Psi} \implies \tyctxrelFL{N+1}{\Rext{R}}{\Psi,\Prp} \tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  \label{lem:tyr_fl_tot_pres}
  The type-relation $\tyr^R$ is left-total and preserves type formation:
  \begin{align*}
    \istyF{N}{A} \implies \mAll {R\,\Psi} \tyctxrelFL{N}{R}{\Psi} \implies \mEx a A \tyr^R a \mAnd \typingL{\Psi}{a}{\Prp}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\istyF{N}{A}$. The two binder cases use Fact~\ref{fac:inv-tyfl-ext}.
\end{proof}

For the inverse direction we establish preservation of type formation and right totality along the following invariant:
\begin{align*}
  \tyctxrelLF{N}{R}{\Psi} \eqdef \mAll {y} y\of\Prp \inL \Psi \implies \mEx x x\,R\,y \mAnd x < N
\end{align*}
\begin{fact}
  \label{fac:inv-tylf-ext}
  The invariant $\tyctxrelLF{N}{R}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tyctxrelLF{N}{R}{\Psi} \implies \typingL{\Psi}{a}{\Prp} \implies \tyctxrelLF{N}{\Rshift{R}}{\Psi,a} & &\tyctxrelLF{N}{R}{\Psi} \implies \tyctxrelLF{N+1}{\Rext{R}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  \label{lem:tyr_lf_tot_pres}
  The type-relation $\tyr^R$ is right-total and preserves type formation:
  \begin{align*}
    \typingL{\Gamma}{a}{\Prp} \implies \mAll {R\,N} \tyctxrelLF{N}{R}{\Gamma} \implies \mEx A A \tyr^R a \mAnd \istyF{N}{A}
  \end{align*}
\end{lemma}
\begin{proof}
  Induction on $\typingL{\Gamma}{a}{\Prp}$, using Fact~\ref{fac:inv-tylf-ext}.
  One complication is the disambiguation of a given PTS-product $\Prod{a} b$, where $a$ is known to live in some universe $u$.
  Discriminating on $u$ allows us to correctly choose either an arrow type $A \to B$, or a universal quantification $\All B$.
  Further requirements are the degeneracy of the universe $\Typ$ ($\Prp$ is the only inhabitant of $\Typ$), as well as propagation and substitutivity for $\tyL$.
\end{proof}

The preservation and totality results for $\tmr^R_S$ make the overhead for explicitly tracking contextual information most apparent.
Since some of the typing rules for applications ascribe types that are constructed from a non-trivial substitution operation, we require substitutivity results for the judgements under consideration; in particular, $\beta$-substitutivity for $\tyr^R$:
\begin{fact}
  The type relation $\tyr^R$ is closed under $\beta$-substitutions:
  \begin{align*}
    B \tyr^R b \implies A \tyr^{\Rext{R}} a \implies A\subst{B\scons\id} \tyr^R a\subst{b\scons\id} \tag*{\qedsymbol}
  \end{align*}
\end{fact}
The proof of this fact is a lengthy but straightforward construction that first generalises the two concrete $\beta$-substitutions to arbitrary parallel substitutions $\sigma$ and $\tau$.
The result is still not provable directly, as closure of $\tyr^R$ under weakening is needed.
This in turn is generalised to a statement for arbitrary renamings $\xi$ and $\zeta$ in place of $\sigma$ and $\tau$.
In essence we establish a CML for $\tyr^R$.

We can now tackle the technically most intricate part of the proof.
The invariant for preservation of typing from F to \SysL is
\begin{align*}
  \tmctxrelFL{\Gamma}{R}{S}{\Psi} \eqdef \mAll {x A} \Gamma_x = A \implies \mEx{y a} A \tyr^R a \mAnd x\,S\,y \mAnd y \of a \inL \Psi
\end{align*}
\begin{fact}
  \label{fac:inv-tmfl-ext}
  The invariant $\tmctxrelFL{\Gamma}{R}{S}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
  &\tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies A \tyr^R a \implies \tmctxrelFL{\Gamma,A}{\Rshift{R}}{\Rext{S}}{\Psi,a} & &\tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies \tmctxrelFL{\Gamma\subst{\shift}}{\Rext{R}}{\Rshift{S}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  The term relation $\tmr^R_S$ is left-total and preserves typing.
  \begin{align*}
    \typingF{\cc{N}{\Gamma}}{s}{A} \implies &\mAll{R S \Psi} R\ms\ms\mathsf{func} \implies \tyctxrelFL{N}{R}{\Psi} \implies \tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies \\
                                            &\mEx{b a} A \tyr^R a \mAnd s \tmr^R_S b \mAnd \typingL{\Psi}{b}{a} \mAnd \typingL{\Psi}{a}{\Prp}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\typingF{\cc{N}{\Gamma}}{s}{A}$.
  Both the invariant $\tmctxrelFL{\Gamma}{R}{S}{\Psi}$, as well as Lemma~\ref{lem:tyr_fl_tot_pres}, are used to obtain related types in the variable case.
  Functionality of $R$ allows us to equate these.
\end{proof}

The final part is the preservation of typing from \SysL to F.
Here we use:
\begin{align*}
  \tmctxrelLF{\Gamma}{R}{S}{\Psi} \eqdef \mAll{y a} y \of a \inL \Psi \implies \typingL{\Psi}{a}{\Prp} \implies \mEx{x A} A \tyr^R a \mAnd x\,S\,y \mAnd x \of A \in \Gamma
\end{align*}
\begin{fact}
  \label{fac:inv-tmfl-ext}
  The invariant $\tmctxrelLF{\Gamma}{R}{S}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies A\,\tyr^R\,a \implies \tmctxrelLF{\Gamma,A}{\Rshift{R}}{\Rext{S}}{\Psi,a} & &\tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies \tmctxrelLF{\Gamma\subst{\shift}}{\Rext{R}}{\Rshift{S}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  The term relation $\tmr^R_S$ is right-total and preserves typing:
  \begin{align*}
    \typingL{\Psi}{a}{\Prp} \implies \typingL{\Psi}{b}{a} \implies &\mAll{R S N \Gamma} R\ms\ms\mathsf{inj} \implies \tyctxrelLF{N}{R}{\Psi} \implies \tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies \\
                                                                &\mEx{s A} A \tyr^R a \mAnd s \tmr^R_S b \mAnd \typingF{\cc{N}{\Gamma}}{s}{A} \mAnd \istyF{N}{A}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\typingL{\Psi}{b}{a}$.
  The cases are mostly analogue to the previous result.
  Injectivity of $R$ is required for the variable case.
  Note that we need to discriminate on the universes of product domains again (cf.\ Lemma~\ref{lem:tyr_lf_tot_pres}), here to disambiguate the unified abstractions and applications correctly.
\end{proof}

At this point we make an interesting observation.
The above proof demonstrates that the CML proof pattern not only generalises to a multi system setting~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq} but also to relations in place of functional correspondences.
This is what allowed us to quickly generate all the contextual invariants need for the various results.

\section{Abella}
\label{sec:abella}

\newcommand{\aje}[1]{\ensuremath{\{#1\}}}
\newcommand{\aj}[2]{\ensuremath{\{#1 \vdash #2\}}}
\newcommand{\ac}[3]{\ensuremath{\mathbb{C}_{#1}^{#2} (#3)}}
\newcommand{\acFty}[1]{\ac{F}{\ty}{#1}}
\newcommand{\acFtm}[1]{\ac{F}{\tm}{#1}}
\newcommand{\acR}[3]{\ac{R}{~}{#1 \mid #2 \mid #3}}

\begin{figure}
  \begin{center}
    \small
    \begin{mathpar}
      \mprset{andskip=2em,sep=2em}
      \inferrule*{\istyFh{A} \\ \istyFh{B}}{\istyFh{(A \to B)}} \and
      \inferrule*{\lpPi x \istyFh{x} \lpImp \istyFh{\lpApp{A}{x}}}{\istyFh{(\All{A})}} \and
      \inferrule*{\typingFh{s}{\All{B}} \\ \istyFh{A}}{\typingFh{s\,A}{\lpApp{B}{A}}} \and
      \inferrule*{\typingFh{s}{A \to B} \\ \typingFh{t}{A}}{\typingFh{s\,t}{B}}\\
      \inferrule*{\lpPi x \istyFh{x} \lpImp \typingFh{\lpApp{s}{x}}{\lpApp{A}{x}}}{\typingFh{\TyLam{s}}{\All{A}}} \and
      \inferrule*{\istyFh{A} \\ \lpPi x \typingFh{x}{A} \lpImp \typingFh{\lpApp{s}{x}}{B}}{\typingFh{\Lam A s}{A \to B}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{HOAS specification of F in Abella.\vspace{-1em}}
  \label{fig:sys-f-abella}
\end{figure}

\begin{figure}
  \begin{center}
    \small
    \begin{mathpar}
      \mprset{andskip=1.5em,sep=1.5em}
      \inferrule*{~}{\sortLh{\Typ}} \and
      \inferrule*{~}{\sortLh{\Prp}} \and
      \inferrule*{~}{\typingLh{\Prp}{\Typ}} \and
      \inferrule*{\typingLh{a}{\Prod{c}{d}} \\ \typingLh{b}{c}}{\typingLh{a\,b}{\lpApp{d}{b}}} \and
      \inferrule*{\typingLh{a}{u} \\ \sortLh{u} \\ \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{b}{x}}{\Prp}}{\typingLh{\Prod{a}{b}}{\Prp}} \and
      \inferrule*{\typingLh{a}{u} \\ \sortLh{u} \\  \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{c}{x}}{\Prp} \\ \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{b}{x}}{\lpApp{c}{x}}}{\typingLh{\Lam{a}{b}}{\Prod{a}{c}}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{HOAS specification of \SysL in Abella.\vspace{-1em}}
  \label{fig:sys-l-abella}
\end{figure}

\enlargethispage{\baselineskip}

Abella supports the use of higher-order abstract syntax (HOAS)~\cite{DBLP:conf/pldi/PfenningE88}.
The main idea is to delegate variable binding at the object level to binding at the meta level.
Take for example the term constructor $\mathsf{lam} \OF (\mathsf{tm} \to \mathsf{tm}) \to \mathsf{tm}$ that yields an abstraction of the untyped $\lambda$-calculus.
The $s$ in $\mathsf{lam}\,s$ is a function of the meta level.
Substitution at the object level is implemented as application at the meta level, which we denote by $\lpApp{s}{t}$ to distinguish it from the various object level applications.

Note that HOAS is not inductive, due to the negative occurrences of expression types.
It also relies on intensional function spaces at the meta level in order to structurally analyse functions.
Both aspects prevent Coq from natively supporting HOAS.

Abella is a system designed around a two-level logic approach.
The lower \emph{specification level}, essentially verbatim $\lambda$Prolog, is used to encode the object languages and their associated judgements.
We then reason about these encoding at the \emph{meta level}, using the logic $\mathcal{G}$, which is the intuitionistic predicative fragment of Church's simple type theory, extended with natural induction, (co)inductive predicates and nominal quantification ($\nabla x . \ms s$).
The axioms of $\mathcal{G}$ ensure that a $\nabla$-quantified identifier is fresh for everything bound above it.
We are going to use these freshness guarantees to faithfully represent object level variables.

The two levels are connected with a special inductive predicate that embeds the derivation of a $\lambda$Prolog judgement $J$ from hypotheses $L = I_0,\ldots,I_n$ into $\mathcal{G}$, written $\aj{L}{J}$, or simply $\aje{J}$ in the absence of assumptions.
Note that $\lambda$Prolog supports hypothetical ($J_1 \lpImp J_2$) and locally quantified ($\lpPi{x} J\subst{x}$) premises, which the embedding treats as follows:
\begin{align*}
  \aj{L}{J_1 \lpImp J_2} &\quad\leadsto\quad \aj{L, J_1}{J_2} & \aj{L}{\lpPi{x} J\subst{x}}&\quad\leadsto\quad \nabla x. \aj{L}{J\subst{x}}
\end{align*}

For the quantification case, observe that the context $L$ is usually bound at the outermost level, hence $x$ is guaranteed to be fresh for $L$, satisfying the usual side condition for context extension rules.
This process is often referred to as \emph{mobility of binders}: object level binders are represented using $\lambda$Prolog quantification, which in turn is mapped to $\nabla$-quantification in~$\mathcal{G}$ and eventually opened with nominal constants $n_i$.
\begin{fact}
  \label{fac:ab-cut-inst}
  The embedding $\aj{L}{J}$ satisfies cut and a nominal instantiation principle:
  \begin{align*}
    &\aj{L}{I} \implies \aj{L,I}{J} \implies \aj{L}{J} \tag{cut} \\
    &\mAll{s \of \mathsf{typeof}\, n_i} \aj{L\subst{n_i}}{J\subst{n_i}} \implies \aj{L\subst{s}}{J\subst{s}} \tag{inst}
  \end{align*}
  Both are exposed as proof tactics to the user.\hfill\qedsymbol
\end{fact}
Note that Fact~\ref{fac:ab-cut-inst} provides substitutivity for the various judgements of our object languages.
It is also worth noting that only the judgements, but not the specification level types like~$\TmL$ and $\TyF$, are embedded, so we cannot induct directly on our syntax definitions.

At this point it should be straightforward to understand the HOAS representation of our two systems given in Figs.~\ref{fig:sys-f-abella}~and~\ref{fig:sys-l-abella}.
For F, the judgements $\istyFh{A}$ and $\typingFh{s}{A}$ encode type formation and respectively typing.
For \SysL, the judgement $\sortLh{u}$ is used to recognise universes, while $\typingLh{a}{b}$ represents PTS typing.

As soon as we try to prove structural results about these definitions we are faced with a problem.
Consider the following inversion principle for arrow type formation in F:
\begin{align*}
  \aj{L}{\istyFh{A \to B}} \implies \aj{L}{\istyFh{A}} \mAnd \aj{L}{\istyFh{B}}
\end{align*}

The premise may hold due to backchaining and $\istyFh{A \to B} \in L$.
The problem is that $L$ is too general and may contain arbitrary judgements, not even necessarily related to type formation.
Hence we need to somehow constrain $L$ to only contain judgements of the form~$\istyFh{n_i}$, where the $n_i$ are nominals representing variables.
Similarly we want to constrain typing contexts to only contain judgements of the form $\istyFh{n_i}$ or $\typingFh{n_i}{A}$.
We specify this notion of well-formed contexts  with auxiliary inductive $\mathcal{G}$-predicates.
The well-formedness predicate for F typing contexts, written $\acFtm{-}$, is defined as:

\vspace{-.5em}
{\small
\begin{mathpar}
  \inferrule*{~}{\acFtm{\emptyctx}} \and
  \inferrule*[right=$x \notin L$]{\acFtm{L}}{\acFtm{L,\istyFh{x}}}\and
  \inferrule*[right={$x \notin L,A$}]{\acFtm{L} \\ \aj{L}{\istyFh{A}}}{\acFtm{L,\typingFh{x}{A}}}
\end{mathpar}
}\vspace{-1em}

The freshness conditions are implemented by locally $\nabla$-quantifying the respective variable.
Next we have to pair this definition with an inversion principle that reveals the structure and freshness properties of any $J \in L$ with $\acFtm{L}$.
At this point we are able to add $\acFty{L}$, defined analogously to $\acFtm{L}$, as an extra premise to our inversion principle and then discard the spurious context extraction.
This relies on the fact that $\nabla x . (A \to B) \neq x$ holds in $\mathcal{G}$.
A key aspect of formalising our equivalence result in Abella is the correct choice of well-formedness predicates and associated inversion Lemmas.

Let us now consider the second equivalence proof.
The relations $\tyr$ and $\tmr$ are defined as:

\vspace{-.5em}
{\small
\begin{mathpar}
  \mprset{andskip=1.5em,sep=1.5em}
  \inferrule*{A \tyr a \\ \lpPi {x} B \tyr \lpApp{b}{x}}{A \to B \tyr \Prod a b} \and
  \inferrule*{\lpPi{x y} x \tyr y \lpImp \lpApp{A}{x} \tyr \lpApp{a}{y}}{\All A \tyr \Prod \Prp a} \and
  \inferrule*{s \tmr a \\ t \tmr b}{s\,t \tmr a\,b} \and
  \inferrule*{A \tyr a \\ \lpPi{x y} x \tmr y \lpImp \lpApp{s}{x} \tmr \lpApp{b}{y}}{\Lam A s \tmr \Lam a b} \and
  \inferrule*{\lpPi{x y} x \tyr y \lpImp \lpApp{s}{x} \tmr \lpApp{a}{y}}{\TyLam s \tmr \Lam \Prp a} \and
  \inferrule*{s \tmr a \\ A \tyr b}{s\,A \tmr a\,b}
\end{mathpar}
}\vspace{-1em}

We complement this definition with a well-formedness predicate $\ac{\tmr}{~}{L}$, which ascertains that $L$ only contains judgements of the form $n_i \tyr n_j$ or $n_i \tmr n_j$, together with suitable lookup lemmas.
For technical reasons we do not define $\ac{\tyr}{~}{-}$ and instead prove a strengthening lemma which holds due to the inferred subordination ordering of the two relations:
\begin{align*}
  \ac{\tmr}{~}{L} \implies \aj{L, x \tmr y}{A \tyr a} \implies \aj{L}{A \tyr a}
\end{align*}

Before we go on, it is interesting to consider the information encapsulated in $\ac{\tmr}{~}{L}$.
The obvious part is that $L$ contains exactly the same information about corresponding variables that we had to track in Coq with the auxiliary parameters $R$ and $S$.
In addition, since $L$ only contains pairings of fresh nominals, we immediately obtain that $L$ is functional and injective.
Lifting these properties to $\tyr$ and then to $\tmr$ are routine inductions.

When it comes to the totality and preservation statements, things become more interesting.
The remaining four lemma statements are generalised over three different contexts belonging to the three involved judgements.
Not only do we require these contexts to be well-formed, but we also have to connect them.
We achieve this with a single ternary well-formedness predicate, $\acR{-}{-}{-}$, defined as follows:

\vspace{-.5em}
{\small
\begin{mathpar}
  \mprset{andskip=.8em,sep=1em}
  \inferrule*{~}{\acR{\emptyctx}{\emptyctx}{\emptyctx}} \and
  \inferrule*{\acR{L_{F}}{L_{\tmr}}{L_{\lambda}} \\ x, y \notin L_{i}}{\acR{L_{F}, \istyFh{x}}{L_{\tmr}, x \tyr y}{L_{\lambda}, \typingLh{y}{\Prp}}} \and
  \inferrule*{\acR{L_{F}}{L_{\tmr}}{L_{\lambda}} \\ x, y \notin L_{i},A,a \\\\ \aj{L_{F}}{\istyFh{A}} \\ \aj{L_{\tmr}}{A \tyr a} \\ \aj{L_{\lambda}}{\typingLh{a}{\Prp}}}{\acR{L_{F}, \typingFh{x}{A}}{L_{\tmr}, x \tmr y}{L_{\lambda}, \typingLh{y}{a}}}
\end{mathpar}
}\vspace{-1em}

When a binder is traversed, this ensures that all three contexts are extended with the same freshly chosen variables $x$ and $y$.
The definition is accompanied by three extraction lemmas, one for each of the three involved contexts, which provide the associated judgements from the two other contexts.
Recall that in Coq we had four separate invariants for the four preservation and totality lemmas.
Here, this information is uniformly encoded in~$\acR{L_{F}}{L_{\tmr}}{L_{\lambda}}$ and we use it for all four proofs.
\begin{lemma} The type relation $\tyr$ is total from F to \SysL and preserves type formation.
  \begin{align*}
    \aj{L_{F}}{\istyFh{A}} \implies \mAll{L_{\tmr}L_{\lambda}} \acR{L_{F}}{L_{\tmr}}{L_{\lambda}} \implies \mEx{a} \aj{L_{\tmr}}{A \tyr a} \mAnd \aj{L_{\lambda}}{\typingLh{a}{\Prp}}
\end{align*}
\end{lemma}
\begin{proof}
  By induction on $\aj{L_{F}}{\istyFh{A}}$.
\end{proof}
As a trivial corollary we obtain: $\aje{\istyFh{A}} \implies \mEx{a} \aje{A \tyr a} \mAnd \aje{\typingLh{a}{\Prp}}$.

The proofs of the remaining three preservation results are surprisingly analogue, so we will not go into further detail.
It is worth pointing out, though, that we again require the degeneracy of the PTS universe $\Typ$, as well as propagation for both F and \SysL in various places.
The HOAS setup allows us to obtain these easily.

\section{Beluga}
\label{sec:beluga}
\input{beluga.tex}

\section{Conclusion}
\label{sec:conclusion}

We have considered a technically interesting proof and demonstrated how various formalisation techniques deal with the arising intricacies.
The development of three different formalisations allowed us to gain deep insights into the inherent complexities of the proof.
In particular we were able to separate these from technical artefacts due to the chosen formalisation technique.
Two examples of inherent complications are the not quite perfectly aligned binding structures and the missing typing information required to disambiguate the uniform PTS applications.

Our set of developments demonstrates, that the various formalisation techniques can be arranged in a hierarchy of abstraction layers.
At the lowest level we have pure de Bruijn with a lot of representation freedom, which, however, has to be manged manually.
Higher up in the hierarchy sit the HOAS techniques, which hide a lot of the technicalities and provide a more meaningful abstraction.
In comparison with Abella, Beluga appears to deliver the theoretically nicer interface, with the added features of contextual reasoning and the ability to perform inductions directly over the HOAS syntax.
Practically though, both systems are relatively young with certain usability issues.
Among the two, Abella's tactic language certainly gives it a head start.

We observe that our proof contains a number of challenges that, taken as a whole, constitute a nice benchmark for systems designed to reason about type systems.
It tests in particular, how well multiple type systems with binding constructs can be brought into correspondence.
We hence propose it as a complement to the POPLmark challenge~\cite{poplmark} on the one hand, which solely tests how well a system can reason about a single type system, and the ORBI benchmarks~\cite{Felty:ITP10,Felty:orbi-survey} which cover small-scale contextual reasoning.
It is our believe that such a benchmark could be very useful to those who seek to develop or improve frameworks for reasoning about type systems and similar syntactic systems with variable binding and complex contextual information.

\subsection{Future Work}
\label{sec:future-work}

We would like to continue this line of work into three largely orthogonal directions.

First, we would like to widen the scope of the benchmark itself and include a correspondence result for the computational behaviour of the two systems.
Equi-reducebility is at least as interesting a problem as equi-typability, and likely to pose its own set of challenges.
One of these is the fact that, prior to typing, \SysL has a lot more $\beta$-redices than its stratified counterpart, hence some form of typing information will have to be tracked along with the relational assumptions.
This will lead to new forms of contexts that are likely comparable in complexity to those discussed here.

Second, we would like to test further frameworks against our benchmark.
One candidate is the locally nameless approach~\cite{DBLP:conf/popl/AydemirCPPW08}.
It provides an abstraction layer that sits somewhere between pure de Bruijn and HOAS.
Our benchmark could test how stable this layer really is.
Another is the HYBRID framework~\cite{DBLP:journals/jar/FeltyM12} that aims to bring HOAS to Coq.
At present however, it is neither equipped with Abella's $\nabla$ nor Beluga's contextual types, so it remains to be seen if it can handle our challenge.
It would also be interesting to see how a system like Twelf~\cite{DBLP:conf/cade/PfenningS99} would handle the rich context structures.

Finally, we consider scaling the challenge both down to the simply typed $\lambda$-calculus, as well as up to F$_\omega$, to obtain a better understanding of where exactly certain complications originate from.

%%
%% Bibliography
%%

% \bibliography{ref-short,bp-extract}
\bibliography{ref-short}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
