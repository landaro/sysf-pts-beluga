\documentclass[a4paper,UKenglish]{lipics-v2016}

\usepackage{microtype}%if unwanted, comment out or use option "draft"

% custom packages
\usepackage{mathpartir}
\usepackage{xspace}
\usepackage{etoolbox}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{empheq}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\TirNameStyle}[1]{\small \textsf{#1}}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Relating System F and $\lambda2$: A Case Study in Coq, Abella and Beluga}
\titlerunning{Relating System F and $\lambda2$}

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Jonas Kaiser}
\author[2]{Brigitte Pientka}
\author[3]{Gert Smolka}
\affil[1]{Saarland University, Saarbrücken, Germany\\
  \texttt{jkaiser@ps.uni-saarland.de}}
\affil[2]{School of Computer Science, Montreal, Canada\\
  \texttt{bpientka@cs.mcgill.ca}}
\affil[3]{Saarland University, Saarbrücken, Germany\\
  \texttt{smolka@ps.uni-saarland.de}}
\authorrunning{J. Kaiser, B. Pientka and G. Smolka} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Jonas Kaiser, Brigitte Pientka and Gert Smolka}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{F.4.1 Mathematical Logic -- Lambda calculus and related systems}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation".
\keywords{Pure Type Systems, System F, de Bruijn Syntax, Higher-Order Abstract Syntax, Contextual Reasoning}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{Dale Miller}
\EventNoEds{1}
\EventLongTitle{2nd International Conference on Formal Structures for Computation and Deduction (FSCD 2017)}
\EventShortTitle{FSCD 2017}
\EventAcronym{FSCD}
\EventYear{2017}
\EventDate{September 3--9, 2017}
\EventLocation{Oxford, UK}
\EventLogo{}
\SeriesVolume{84}
\ArticleNo{21}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% Content macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% uniform meta space
\newcommand{\ms}{\,}
\newcommand{\mrel}[1]{\mathrel{\ms #1 \ms}}

% Meta-Level Propositions
\newcommand{\Prop}{\ensuremath{\mathbf{Prop}}}
\newcommand{\Type}{\ensuremath{\mathbf{Type}}}
\newcommand{\Nat}{\mathbb{N}}

% Meta-level Symbols and Operators
\newcommand{\dom}[1]{\ensuremath{\textrm{dom$\,#1$}}}
\newcommand{\OF}{\mrel{:}}
\newcommand{\mOr}{\mrel{\vee}}
\newcommand{\mAnd}{\mrel{\wedge}}
\newcommand{\mAll}[1]{\ensuremath{\forall} #1.\ms\ms}
\newcommand{\mEx}[1]{\ensuremath{\exists} #1.\ms\ms}
\newcommand{\mExu}[1]{\ensuremath{\exists!} #1.\ms\ms}
\newcommand{\bnfdef}{\mrel{::=}}
\newcommand{\eqdef}{\mrel{:=}}
\newcommand{\set}[1]{\ensuremath{\{#1\}}}

\newcommand{\SysL}{$\lambda2$\xspace}


% Syntactic sorts of the object languages
\newcommand{\TyF}{\ensuremath{\mathsf{Ty_{F}}}}
\newcommand{\TmF}{\ensuremath{\mathsf{Tm_{F}}}}
\newcommand{\TmL}{\ensuremath{\mathsf{Tm_{\lambda}}}}

\newcommand{\TyCtxF}{\ensuremath{\mathsf{C_{F}^{ty}}}}
\newcommand{\TmCtxF}{\ensuremath{\mathsf{C_{F}^{tm}}}}
\newcommand{\CtxL}{\ensuremath{\mathsf{C_{\lambda}}}}
\newcommand{\TyCtxR}{\ensuremath{\mathsf{C_{R}^{ty}}}}
\newcommand{\TmCtxR}{\ensuremath{\mathsf{C_{R}^{tm}}}}


% Generic type-system judgement predicates
\newcommand{\istyFpr}{\ensuremath{\mathsf{isty_{F}}}}
\newcommand{\typingFpr}{\ensuremath{\mathsf{ofty_{F}}}}
\newcommand{\typingLpr}{\ensuremath{\mathsf{ofty_{\lambda}}}}

% Judgements
\newcommand{\ty}{\mathsf{ty}}
\newcommand{\tm}{\mathsf{tm}}
\newcommand{\of}{\ensuremath{\!:\!}}
\newcommand{\cc}[2]{#1;#2} % compound System F contexts
\makeatletter
\newcommand{\raisemath}[1]{\mathpalette{\raisem@th{#1}}}
\newcommand{\raisem@th}[3]{\raisebox{#1}{\ensuremath{#2#3}}}
\makeatother
\newcommand{\tsAnnot}[2]{\vdash\hspace{-.7em}^{\raisemath{1.5pt}{\scriptscriptstyle{#2}}}_{\raisemath{0.3pt}{\scriptscriptstyle{#1}}}} % note: wrap instances in \mathbin
\newcommand{\cts}[2]{\ensuremath{(\,#1 #2 {})}} % context + turnstile for CMs
\newcommand{\tfF}{\tsAnnot{\mathsf{F}}{\ty}}  % for type formation judgement
\newcommand{\tyF}{\tsAnnot{\mathsf{F}}{\tm}}  % for typing judgement
\newcommand{\istyF}[2]{\ensuremath{{#1} \mathrel{\tfF} #2}}
\newcommand{\typingF}[3]{\ensuremath{{#1} \mathrel{\tyF} #2 \OF #3}}
\newcommand{\tyL}{\tsAnnot{\lambda}{}} % for typing judgement
\newcommand{\typingL}[3]{\ensuremath{{#1} \mathrel{\tyL} #2 \OF #3}}
\newcommand{\inL}{\mrel{\in_{\lambda}}}
\newcommand{\tfP}{\tsAnnot{\mathsf{P}}{\ty}}  % for type formation judgement
\newcommand{\istyFh}[1]{\ensuremath{#1\ms\mathsf{ty}}}
\newcommand{\typingFh}[2]{\ensuremath{#1 \mathbin{:_{\mathsf{F}}} #2}}
\newcommand{\sortLh}[1]{\ensuremath{\mathcal{U}\ms#1}}
\newcommand{\typingLh}[2]{\ensuremath{#1 \mathbin{:_{\lambda}} #2}}


% The type and term relations
\newcommand{\tyr}{\mathrel{\sim}}
\newcommand{\tmr}{\mathrel{\approx}}

\newcommand{\Rext}[1]{\ensuremath{#1^{\mathsf{ext}}}}
\newcommand{\Rshift}[1]{\ensuremath{#1^{\Uparrow}}}

% relational context morphisms
\newcommand{\tyctxrelFL}[3]{\ensuremath{#1\mathrel{\mathop{\longrightarrow}^{#2}\limits}#3}}
\newcommand{\tyctxrelLF}[3]{\ensuremath{#1\mathrel{\mathop{\longleftarrow}^{#2}\limits}#3}}
\newcommand{\tmctxrelFL}[4]{\ensuremath{#1\mathrel{\mathop{\longrightarrow}^{#2}_{#3}\limits}#4}}
\newcommand{\tmctxrelLF}[4]{\ensuremath{#1\mathrel{\mathop{\longleftarrow}^{#2}_{#3}\limits}#4}}

% L-Prolog syntax
\newcommand{\lpPi}[1]{\mathbf{\Pi} #1.\ms\ms}
\newcommand{\lpApp}[2]{#1\langle#2\rangle}
\newcommand{\lpImp}{\mrel{=\!\blacktriangleright}}

% Object Syntax
\newcommand{\Prp}{\ensuremath{\textrm{\textasteriskcentered}}}
\newcommand{\Typ}{\ensuremath{\square}}
\newcommand{\All}{\ensuremath{\forall.\,}}
\newcommand{\nAll}[1]{\ensuremath{\forall #1.\,}}
\newcommand{\Lam}[1]{\ensuremath{\lambda #1.\,}}
\newcommand{\TyLam}{\ensuremath{\Lambda.\,}}
\newcommand{\nTyLam}[1]{\ensuremath{\Lambda #1.\,}}
\newcommand{\Prod}[1]{\ensuremath{\Pi #1.\,}}

\newcommand{\emptyctx}{\ensuremath{\bullet}}

% Substitutions
\newcommand{\subst}[1]{\hphantom{|}\!\![{#1}]}
%\newcommand{\scons}{\mathbin{\hspace{0.05em}\cdot\hspace{0.05em}}}
\newcommand{\scons}{\mathbin{\cdot}}
% \newcommand{\scomp}{\mathbin{\hspace{-0.1em}{\circ}\hspace{-0.1em}}}
\newcommand{\scomp}{\mathbin{\circ}}
\newcommand{\hscomp}{\mathbin{\hspace{-0.1em}{\hat\circ}\hspace{-0.1em}}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\up}{{\Uparrow}}
% \newcommand{\shift}{\ensuremath{\hspace{0.1em}\mathsf{+}\hspace{0.08em}\!1}}
\newcommand{\shift}{\ensuremath{\uparrow}}
\newcommand{\ushift}{\ensuremath{\hspace{0.1em}\textsf{--}\hspace{0.1em}\!1}}

% Facts without proof
\theoremstyle{plain}
\newtheorem{fact}[theorem]{Fact}

%%% Content macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle
%\raggedbottom

\begin{abstract}
  We give three formalisations of a proof of the equivalence of the usual, two-sorted presentation of System~F and its single-sorted pure type system (PTS) variant $\lambda2$.
  This is established by reducing the typability problem of F to $\lambda2$ and vice versa.
  A key challenge is the treatment of variable binding and contextual information.
  The formalisations all share the same high level proof structure using relations to connect the type systems.
  They do, however, differ significantly in their representation and manipulation of variables and contextual information.
  In Coq, we use pure de~Bruijn indices and parallel substitutions.
  In Abella, we use higher-order abstract syntax (HOAS) and nominal constants of the ambient reasoning logic.
  In Beluga, we also use HOAS but within contextual modal type theory.
  Our contribution is twofold.
  First, we present and compare a collection of machine-checked solutions to a non-trivial theoretical result.
  Second, we propose our proof as a benchmark, complementing the POPLmark and ORBI challenges by testing how well a given proof assistant or framework handles complex contextual information involving multiple type systems.
\end{abstract}

\section{Introduction}
\label{sec:intro}

\begin{figure}[t]
  \begin{center}
    \small
    \begin{align*}
      \Aboxed{\TyF} & A, B &\bnfdef X \mid A \to B \mid \nAll X A & \quad\qquad\Aboxed{\TmF} & s, t &\bnfdef x \mid s\,t \mid \Lam {x \of A} s \mid s\,A \mid \nTyLam X s\\
      \Aboxed{\TyCtxF} & \Delta &\bnfdef \emptyset \mid \Delta, X & \quad\qquad\Aboxed{\TmCtxF} & \Gamma &\bnfdef \emptyctx \mid \Gamma, x \of A
    \end{align*}
    \begin{mathpar}
      \inferrule*{X \in \Delta}{\istyF{\Delta}{X}} \and
      \inferrule*{\istyF{\Delta}{A} \\ \istyF{\Delta}{B}}{\istyF{\Delta}{A \to B}} \and
      \inferrule*[right=$X \notin \Delta$]{\istyF{\Delta,X}{A}}{\istyF{\Delta}{\nAll X A}} \and
      \inferrule*{\Gamma(x)=A \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{x}{A}} \\
      \inferrule*{\typingF{\cc{\Delta}{\Gamma}}{s}{A \to B} \\ \typingF{\cc{\Delta}{\Gamma}}{t}{A}}{\typingF{\cc{\Delta}{\Gamma}}{s\,t}{B}} \and
      \inferrule*[right=$x \notin \dom{\Gamma}$]{\typingF{\cc{\Delta}{\Gamma,x \of A}}{s}{B} \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{\Lam {x \of A} s}{A \to B}} \\
      \inferrule*{\typingF{\cc{\Delta}{\Gamma}}{s}{\nAll X B} \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{s\, A}{B\subst{A/X}}} \and
      \inferrule*[right=$X \notin \Delta$]{\typingF{\cc{\Delta, X}{\Gamma}}{s}{A}}{\typingF{\cc{\Delta}{\Gamma}}{\nTyLam X s}{\nAll X A}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{Two-sorted System~F: types, terms, contexts, type formation and typing.\vspace{-1em}}
  \label{fig:sys-f}
\end{figure}

\begin{figure}[t]
  \begin{center}
    \small
    \begin{align*}
      \Aboxed{\TmL} & a, b, c, d, u &\bnfdef \Prp \mid \Typ \mid x \mid a\,b \mid \Lam{x \of a} b \mid \Prod{x \of a} b & \qquad\qquad\Aboxed{\CtxL} & \Psi &\bnfdef \emptyctx \mid \Psi, x \of a
    \end{align*}
    \begin{mathpar}
      \mprset{sep=1.5em}
      \inferrule*{~}{\typingL{\Psi}{\Prp}{\Typ}} \and
      \inferrule*{x \of a \in \Psi \\ \typingL{\Psi}{a}{u}}{\typingL{\Psi}{x}{a}} \and
      \inferrule*[right=$x \notin \dom{\Psi}$]{\typingL{\Psi}{a}{u} \\ \typingL{\Psi,x \of a}{b}{\Prp}}{\typingL{\Psi}{\Prod{x \of a} b}{\Prp}} \\
      \inferrule*{\typingL{\Psi}{a}{\Prod{x \of c} d} \\ \typingL{\Psi}{b}{c}}{\typingL{\Psi}{a\, b}{d\subst{b/x}}} \and
      \inferrule*[right=$x \notin \dom{\Psi}$]{\typingL{\Psi}{a}{u} \\ \typingL{\Psi, x \of a}{b}{c} \\ \typingL{\Psi, x \of a}{c}{\Prp}}{\typingL{\Psi}{\Lam{x \of a} b}{\Prod{x \of a} c}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{PTS: terms, contexts, and the type system \SysL; $u$ ranges over the universes $\Prp$ and $\Typ$.\vspace{-1em}}
  \label{fig:sys-l}
\end{figure}

There are different presentations of ``System~F'' in the literature and they are effectively considered equivalent, which is used to justify the transport of theoretical results between said presentations.
The assumed notion of equivalence is primarily a reduction of the typability problem from one system to the other.
While the existence of a suitable correspondence between the systems may appear likely or obvious, it turns out that actually proving it formally is surprisingly intricate.
As long as the systems in question use the same expression syntax, the proofs are usually tedious but straightforward.
If, on the other hand, not only the type systems, but also the syntactic languages differ, then establishing the correct correspondence becomes much more involved.
The goal of this paper is to showcase various formalisation techniques to deal with the intricacies that arise in such an equivalence proof.

%\enlargethispage{\baselineskip}

System~F in its original form is due to Girard~\cite{Girard1972, Girard1989}, who introduced it in the context of proof theory.
It was also independently discovered by Reynolds~\cite{DBLP:conf/programm/Reynolds74} as the polymorphic $\lambda$-calculus.
For the purpose of this paper we consider two presentations that differ sufficiently to demonstrate the various complications.
The first, called F and shown in Figure~\ref{fig:sys-f}, is the common two-sorted presentation, as for example given by Harper~\cite{Harper2013}.
The second, given in Figure~\ref{fig:sys-l}, is the single-sorted pure type system (PTS) \SysL, which appears as a corner in Barendregt's $\lambda$-cube~\cite{DBLP:journals/jfp/Barendregt91}.

In~\cite{Geuvers1993}, Geuvers gives a proof sketch that valid typing judgements can be translated between these two presentations.
In~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq} we then gave the first proof, machine-checked in Coq, of the full reduction result.
It relied on syntactic translation functions and the construction of an intermediate, F-like type system for the PTS syntax.
The proof presented here is a lot simpler for a number of reasons.
We use relations on the two syntactic languages rather than translation functions, so we do not have to concern ourselves with cancellation laws to establish the reductions.
We can further establish the correspondence directly, which completely bypasses the need for the intermediate type system.

\begin{figure}[t]
  \begin{center}
    \small
    \begin{align*}
      \Aboxed{\TyCtxR} & \Theta &\bnfdef \emptyctx \mid \Theta, (X,y) & \qquad\qquad\Aboxed{\TmCtxR} &\Sigma &\bnfdef \emptyctx \mid \Sigma, (x,y)\hspace{6em}
    \end{align*}
    \begin{mathpar}
      \inferrule*{(X,y) \in \Theta}{\Theta \vdash X \tyr y} \and
      \inferrule*[right=$x \notin \Theta$]{\Theta \vdash A \tyr a \\ \Theta \vdash B \tyr b}{\Theta \vdash A \to B \tyr \Prod{y \of a} b} \and
      \inferrule*[right={$X,y \notin \Theta$}]{\Theta, (X,y) \vdash A \tyr a}{\Theta \vdash \nAll{X} A \tyr \Prod{y \of \Prp} a}\\
      \inferrule*{(x,y) \in \Sigma}{\cc{\Theta}{\Sigma} \vdash x \tmr y} \and
      \inferrule*{\cc{\Theta}{\Sigma} \vdash s \tmr a \\ \cc{\Theta}{\Sigma} \vdash t \tmr b}{\cc{\Theta}{\Sigma} \vdash s\,t \tmr a\,b} \and
      \inferrule*{\cc{\Theta}{\Sigma} \vdash s \tmr a \\ \Theta \vdash A \tyr b}{\cc{\Theta}{\Sigma} \vdash s\,A \tmr a\,b}\\
      \inferrule*[right={$x,y \notin \Theta,\Sigma$}]{\Theta \vdash A \tyr a \\ \cc{\Theta}{\Sigma, (x,y)} \vdash s \tmr b}{\cc{\Theta}{\Sigma} \vdash \Lam{x \of A} s \tmr \Lam{y \of a} b} \and
      \inferrule*[right={$X,y \notin \Theta,\Sigma$}]{\cc{\Theta, (X,y)}{\Sigma} \vdash s \tmr a}{\cc{\Theta}{\Sigma} \vdash \nTyLam{X} s \tmr \Lam{y \of \Prp} a}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{Inductive characterisation of $\tyr$ and $\tmr$; $\Theta$ and $\Sigma$ track related type and term variables.\vspace{-1em}}
  \label{fig:rel}
\end{figure}

The relations that precisely establish the correspondence of our two systems are realised as inductive predicates (Figure~\ref{fig:rel}).
The main advantage over the functional approach is that it allows us to focus on the meaningful, well-typed fragments of the two systems.
Despite these simplifications we still have to face the metaphorical elephant in the room, namely variable binding and context manipulation.
More precisely, we have to represent and handle contexts that track various kinds of information, like the set of defined variables, their associated types, their correspondence to other variables, and so on.
To make the situation fully explicit: our contexts are dependent sequences of dependent records.

In the following we present three formalisations.
They all follow the same basic proof structure, outlined in Section~\ref{sec:equi}, but they each deal with the complexities of contextual information and variable binding in different ways.
In Sections~\ref{sec:coq},~\ref{sec:abella}~and~\ref{sec:beluga} we discuss in detail how this is managed, in order of seniority, in Coq~\cite{CoqWebsite}, Abella~\cite{AbellaTutorial} and respectively Beluga~\cite{Pientka:CADE15}.

The Coq proof assistant, oldest among the three, is a general purpose theorem prover based on constructive mathematics with no particular built-in support for meta-theoretical reasoning.
Since all required structures have to be handled manually, library support is essential.
In our case we use the Autosubst framework~\cite{DBLP:conf/itp/SchaferTS15} that allows us to elegantly work with pure de Bruijn syntax and parallel substitutions.

Meanwhile, both Abella and Beluga allow us to work with higher-order abstract syntax (HOAS), albeit in two rather different background logics.
Both systems are designed explicitly with meta-theoretical reasoning in mind, with suitable support built into the foundation of each system.
The core design of Abella is based around proof search and relational specifications.
It predates the POPLmark challenge~\cite{poplmark}, which shaped the previous decade of formalised meta theory.
Meanwhile Beluga, youngest among the three, was able to incorporate the insights obtained from POPLmark into its design right from the start.
This led to the notion of contextual objects and first class syntactic contexts.
Our three developments demonstrate how the various system designs affect a given formalisation effort.

While the comparison of proofs from different systems in terms of code lines is only marginally meaningful, we were surprised to find that all three developments each take approximately 500 loc, with Beluga slightly on the shorter side and Coq somewhat on the longer.
This, however, only covers establishing the correspondence itself.
The systems require vastly different amounts of code to establish the separate meta theories for the two discussed type systems, due to different levels of background support.

\noindent{\bf Contributions of the paper:}
\begin{enumerate}
\item We present and compare three different machine checked formalisations of the technically intricate reduction of typability from System~F to the PTS \SysL and vice versa.\footnote{The accompanying developments can be found at \url{https://www.ps.uni-saarland.de/extras/fscd17/}}
\item We propose that our equivalence proof serves as a benchmark for reasoning about and relating multiple type systems and languages involving variable binding.
  The key aspect of this benchmark is the representation and manipulation of contexts that track multiple kinds of information and exhibit complex dependency structures.
  As such it can be seen as a complement to the benchmarks proposed in~\cite{Felty:ITP10,Felty:orbi-survey} and the POPLmark challenge~\cite{poplmark}.
\end{enumerate}

\section{Equivalence}
\label{sec:equi}

The core challenge of the proof is the fact that F clearly distinguishes types and terms with separate syntactic sorts, $\TyF$ and $\TmF$ respectively, while \SysL merges these into a single syntactic sort $\TmL$.
The distinction still exists in \SysL but it is semantically imposed through the type system, rather than at the level of syntax.
Further consequences are the existence of two variable scopes in F, with separate abstraction and application mechanisms, while the same concepts are uniformly represented in \SysL for a single variable scope.
This extends to the formation of function spaces as well.
For an in-depth discussion of the mismatches between the two systems see~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}.
In essence, the two systems differ in how explicit and readily available certain structural properties are.
One half of the proof will thus have to reestablish implicit structures, which, as one would expect, is harder than removing it.
This will lead to a certain asymmetry in proof effort for seemingly symmetrical lemma statements.

%\enlargethispage{\baselineskip}

The basic idea of the proof presented here is to construct two relations $\tyr$ and $\tmr$ that put the types and respectively the terms of the two languages in correspondence (see Figure~\ref{fig:rel}).
To obtain the desired equivalence results, we have to demonstrate that these relations exhibit the following properties:
\begin{enumerate}
  \item $\tyr$ is functional and injective.
  \item $\tyr$ is left-total and type-formation preserving on the well-formed types of F.
  \item $\tyr$ is right-total and type-formation preserving on the propositions of \SysL.
    A proposition of \SysL is any term $a \OF \TmL$ such that $\typingL{}{a}{\Prp}$ holds.
  \item $\tmr$ is functional and injective.
  \item $\tmr$ is left-total and typing preserving on the well-typed terms of F.
  \item $\tmr$ is right-total and typing preserving on the proofs of \SysL.
    A proof of \SysL is any term~${b \OF \TmL}$ such that $\typingL{}{b}{a}$ holds for $a$ a proposition of \SysL.
\end{enumerate}
We can now formulate, and easily prove, the following equivalences:

\begin{theorem}[Reductions from F to \SysL]
  \label{thm:red1}
  \begin{align*}
    \istyF{}{A} &\iff \mExu{a} {} \vdash A \tyr a \mAnd \typingL{}{a}{\Prp}\\
    \typingF{}{s}{A} &\iff \mExu{b a} {} \vdash s \tmr b \mAnd {} \vdash A \tyr a \mAnd \typingL{}{b}{a} \mAnd \typingL{}{a}{\Prp}
  \end{align*}
\end{theorem}

\begin{proof}
  The forward directions are simply the corresponding left-to-right preservation and left-totality results of $\tmr$ and $\tyr$.
  Uniqueness follows from functionality.
  For the inverse direction we use preservation (here from right to left) and uniqueness.
\end{proof}

\begin{theorem}[Reductions from \SysL to F]
  \label{thm:red2}
  \begin{align*}
    \typingL{}{a}{\Prp} &\iff \mExu{A} {} \vdash A \tyr a \mAnd \istyF{}{A}\\
    \typingL{}{b}{a} \mAnd \typingL{}{a}{\Prp} &\iff \mExu{s A} {} \vdash s \tmr b \mAnd {} \vdash A \tyr a \mAnd \typingF{}{s}{A}
  \end{align*}
\end{theorem}

\begin{proof}
  Dual to the previous result.
\end{proof}

For the remainder of the paper, we focus on how F, \SysL and the two relations $\tyr$ and $\tmr$ are represented in our three proof systems, and how the six main properties of the relations are obtained.
Establishing Theorems~\ref{thm:red1}~and~\ref{thm:red2} is in each case routine and hence not presented in detail.

\section{Coq}
\label{sec:coq}

\begin{figure}
  \begin{center}
    \small
    \begin{align*}
      A, B &\bnfdef x_\ty \mid A \to B \mid \All A & s, t &\bnfdef x_\tm \mid s\,t \mid \Lam A s \mid s\,A \mid \TyLam s & &x, N \OF \Nat
    \end{align*}
    \begin{mathpar}
      \mprset{andskip=1em,sep=1.1em}
      \inferrule*{x < N}{\istyF{N}{x_\ty}} \and
      \inferrule*{\istyF{N}{A} \\ \istyF{N}{B}}{\istyF{N}{A \to B}} \and
      \inferrule*{\istyF{N+1}{A}}{\istyF{N}{\All A}} \and
      \inferrule*{\Gamma_x = A \\ \istyF{N}{A}}{\typingF{\cc{N}{\Gamma}}{x_\tm}{A}} \and
      \inferrule*{\typingF{\cc{N}{\Gamma}}{s}{\All A} \\\istyF{N}{B}}{\typingF{\cc{N}{\Gamma}}{s\, B}{A\subst{B\scons\id}}} \and
      \inferrule*{\typingF{\cc{N+1}{\Gamma\subst{\shift}}}{s}{A}}{\typingF{\cc{N}{\Gamma}}{\TyLam s}{\All A}} \and
      \inferrule*{\typingF{\cc{N}{\Gamma,A}}{s}{B} \\ \istyF{N}{A}}{\typingF{\cc{N}{\Gamma}}{\Lam A s}{A \to B}} \and
      \inferrule*{\typingF{\cc{N}{\Gamma}}{s}{A \to B} \\ \typingF{\cc{N}{\Gamma}}{t}{A}}{\typingF{\cc{N}{\Gamma}}{s\,t}{B}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{System~F -- de Bruijn encoding in Coq; term variable contexts $\Gamma$ are lists of types.\vspace{-1em}}
  \label{fig:sys-f-coq}
\end{figure}

\begin{figure}
  \begin{center}
    \small
    \begin{align*}
      a, b, c, d &\bnfdef \Prp \mid \Typ \mid x \mid a\,b \mid \Lam a b \mid \Prod a b & &x \OF \Nat
    \end{align*}
    \begin{mathpar}
      \mprset{andskip=1.5em,sep=1.5em}
      \inferrule*{~}{0 \of a\subst{\shift} \inL \Psi,a}\and
      \inferrule*{x \of a \inL \Psi}{(x+1) \of a\subst{\shift} \inL \Psi,b}\and
      \inferrule*{~}{\typingL{\Psi}{\Prp}{\Typ}} \and
      \inferrule*{x \of a \inL \Psi \\ \typingL{\Psi}{a}{u}}{\typingL{\Psi}{x}{a}} \\
      \inferrule*{\typingL{\Psi}{a}{u} \\ \typingL{\Psi,a}{b}{\Prp}}{\typingL{\Psi}{\Prod a b}{\Prp}} \and
      \inferrule*{\typingL{\Psi}{a}{\Prod c d} \\ \typingL{\Psi}{b}{c}}{\typingL{\Psi}{a\, b}{d\subst{b\scons\id}}} \and
      \inferrule*{\typingL{\Psi}{a}{u} \\\\ \typingL{\Psi, a}{b}{c} \\ \typingL{\Psi, a}{c}{\Prp}}{\typingL{\Psi}{\Lam a b}{\Prod a c}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{\SysL{} -- de Bruijn encoding in Coq; dependent contexts $\Psi$ are lists of terms.\vspace{-1em}}
  \label{fig:sys-l-coq}
\end{figure}

%\enlargethispage{\baselineskip}

For the Coq proof we reuse the pure de Bruijn encoding of the two systems and the corresponding meta theories developed in~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}, with major support from the Autosubst framework~\cite{DBLP:conf/itp/SchaferTS15}.
The language definitions are given in Figures~\ref{fig:sys-f-coq}~and~\ref{fig:sys-l-coq}.
The main feature of de Bruijn syntax is the absence of variable names.
Variables are instead represented as numerical indices, where $n$ references the $n$th enclosing binder of the correct scope.
Dangling references represent free variables that instead reference positions in an enclosing context, indexed from right to left.
Note that we preserve the dot as a notational device to uniformly indicate the presence of a binding constructor, even if nothing remains to the left of it (e.g.\ $\TyLam s$).
It marks the precise spot where substitutions and indices have to be adjusted.
The application of a parallel substitution $\sigma$ to a term $s$ is written $s\subst{\sigma}$ where $\sigma$ is a function from $\Nat$ that acts on all free variables of $s$ at once.
The Autosubst framework provides a normalisation procedure for such terms with applied substitutions.
The existence of computable normal forms was demonstrated in~\cite{SchaeferEtAl:2009:Completeness}.
Context morphism lemmas (CML) are a useful proof device to reason about judgements over pure de Bruijn syntax.
In the following we will only focus on those aspects that have an immediate impact on our present proof.
For an in-depth discussion of the interaction of pure de Bruijn syntax, parallel substitutions and CMLs we refer to~\cite{deBruijn1972, SchaeferEtAl:2009:Completeness, DBLP:conf/itp/SchaferTS15, abadi1991, GoguenMcKinna1997, KaiserEtAl:2017:sysf_pts_equiv_coq}.
A brief overview is also given in Appendix~\ref{apdx:db}.

In the definition of F in Figure~\ref{fig:sys-f-coq}, observe how the type variable context $\Delta$ degenerates to a plain natural number $N$.
It is taken as an exclusive upper bound to the admissible type variable indices, hence $N = 0$ represents the empty context.
The term variable context~$\Gamma$ is simply a list of types, since free variables are coded as context positions.
The \linebreak[0]$\beta$-substitution~$B\scons{\id}$ used in the type specialisation rule maps the free index 0 to $B$ and lowers all other indices by 1.

We further observe that for \SysL, defined in Figure~\ref{fig:sys-l-coq}, context lookup is characterised inductively: $x \of a \inL \Psi$.
The need for this arises from the fact that the PTS contexts are dependent as well as the more general issue that in a de Bruijn setting, terms are not stable under context modifications.
Hence, upon extraction of a term $a$ from context $\Gamma$, all free variables of $a$ have to be adjusted by an amount that depends on the position of $a$ in $\Gamma$.
The given inductive characterisation elegantly handles this complication.

{\bf The first equivalence proof.}
Similar to the way typing contexts are explicitly represented as lists of terms or types, we are going to track explicitly which variables are related in our definition of our relations $\tyr^R$ and $\tmr^R_S$.
The relational parameters $R$ and $S$ correspond to the contexts $\Theta$ and $\Sigma$ from Figure~\ref{fig:rel}:

\vspace{-.5em}
{\small
\begin{mathpar}
  \mprset{andskip=1.5em,sep=1.5em}
  \inferrule*{x\,R\,y}{x_\ty\,\tyr^R\,y} \and
  \inferrule*{A\,\tyr^R\,a \\ B\,\tyr^{\Rshift{R}}\,b}{A \to B\,\tyr^R\,\Prod a b} \and
  \inferrule*{A\,\tyr^{\Rext{R}}\,a}{\All A\,\tyr^R\,\Prod \Prp a} \and
  \inferrule*{x\,S\,y}{x_\tm\,\tmr^R_S\,y} \\
  \inferrule*{s\,\tmr^R_S\,a \\ t\,\tmr^R_S\,b}{s\,t\,\tmr^R_S\,a\,b} \and
  \inferrule*{s\,\tmr^R_S\,a \\ A\,\tyr^R\,b}{s\,A\,\tmr^R_S\,a\,b} \and
  \inferrule*{A\,\tyr^R\,a \\ s\,\tmr^{\Rshift{R}}_{\Rext{S}}\,b}{\Lam A s\,\tmr^R_S\,\Lam a b} \and
  \inferrule*{s\,\tmr^{\Rext{R}}_{\Rshift{S}}\,a}{\TyLam s\,\tmr^R_S\,\Lam \Prp a}
\end{mathpar}
}\vspace{-1em}

The parameters $R$ and $S$ track pairs of indices of type, and respectively, term variables.
We technically represent them as lists of type $\mathsf{list}\,(\mathsf{var} \times \mathsf{var})$ and use $x\,R\,y$ to denote that the pair $(x,y)$ is in $R$.
The interesting part of this definition is how these auxiliary parameters have to be modified when binders are traversed, which we denoted above by $\Rshift{R}$ and $\Rext{R}$.
In order to precisely define these operations, let us recall the required action on a parallel substitution $\sigma$ that is pushed underneath a binder:
\begin{align*}
  (\All A)\subst{\sigma} \qquad\longmapsto\qquad \All A\subst{0 \scons \sigma \scomp \shift}
\end{align*}
The $\subst{0 \scons \_}$ part ensures that any index referencing the presently traversed binder is preserved as such.
Meanwhile the $\subst{\_ \scons \sigma \scomp \shift}$ part ensures that every index $n + 1$ is mapped to $\sigma(n)\subst{\shift}$, where the $\shift$ ensures that no free variables in the range of $\sigma$ are accidentally captured by the traversed binder.

In our correspondence proof we traverse binders \emph{almost} in lockstep.
For the simple cases where we have a binder on both sides of the relation, and moreover, the bound variables actually correspond according to the information tracked in $R$, we define, analogously to the binder traversal for substitutions:
\begin{align*}
  \Rext{R} \eqdef (0,0) \mathop{::} \mathsf{bimap}\,\shift\,\,\shift\,R
\end{align*}
where $\mathsf{bimap}\,f\,g\,R$ simply applies $f$ to all left projections of $R$ and $g$ to all right projections.

The other possible scenario has a binder on the \SysL side that has no counterpart in F with respect to the contextual information in $R$, like the \emph{not-really dependent} PTS product that corresponds to an arrow type in F.
As a consequence of this spurious binding, the \SysL indices in $R$ have to be shifted relative to their F counterparts.
This one-sided index adjustment is obtained with
\begin{align*}
  \Rshift{R} \eqdef \mathsf{bimap}\,\,\id\,\shift\,R
\end{align*}

\begin{fact}
  \label{fac:rel-ext}
  Both $\Rext{R}$ and $\Rshift{R}$ preserve injectivity and functionality of $R$.\hfill\qedsymbol
\end{fact}

\begin{lemma}
  \label{lem:tyr-inj-fun}
  The type relation $\tyr^R$ is injective/functional, whenever $R$ is injective/functional.
\end{lemma}
\begin{proof}
  Straightforward inductions using Fact~\ref{fac:rel-ext}.
\end{proof}

To obtain the same result for $\tmr^R_S$ we additionally rely on $R$ and $S$ having disjoint ranges, that is, no PTS variable is considered related to both a type and a term variable.
We denote this by $R \| S$.
\begin{fact}
  \label{fac:rel-disjoint}
  The property $R \| S$ is preserved under extending one relation and shifting the other, that is w.l.o.g.: $R \| S \implies \Rshift{R} \| \Rext{S}$.\hfill\qedsymbol
\end{fact}
\begin{lemma}
  \label{lem:rel-disjoint}
  Disjointedness of ranges lifts from variable relations $R$ and $S$ to $\tyr^R$ and $\tmr^R_S$:
  \begin{align*}
    R \| S \implies A \tyr^R a \implies s \tmr^R_S a \implies \bot
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $A \tyr^R a$ and discriminating on $s \tmr^R_S a$, using Fact~\ref{fac:rel-disjoint}.
\end{proof}
\begin{lemma}
  \label{lem:tmr-inj-fun}
  The term relation $\tmr^R_S$ is functional, whenever $R$ and $S$ are functional.
  It is injective, whenever $R$ and $S$ are injective and $R \| S$ holds.
\end{lemma}
\begin{proof}
  Straightforward inductions.
  Injectivity relies on the premise $R \| S$ and Lemma~\ref{lem:rel-disjoint} to discharge non-matching applications.
  Subderivations for $\tyr^R$ are handled with Lemma~\ref{lem:tyr-inj-fun}.
\end{proof}

Proving the left and right totality and preservation results is slightly more interesting, as we have to generalise to open judgements and non-empty contexts.
We achieve this with suitable proof invariants that are adapted from the notion of \emph{generalised context morphisms} laid out in~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}.
The key difference is that instead of a renaming $\xi$ that maps from one context to another, we here consider a relation on variables that places two contexts in correspondence.
All invariants are set up such that they vacuously hold when the initial context happens to be empty.
We start with type formation and the direction from F to \SysL:
\begin{align*}
  \tyctxrelFL{N}{R}{\Psi} \eqdef \mAll {x < N} \mEx y x\,R\,y \mAnd y \of \Prp \inL \Psi
\end{align*}
\begin{fact}
  \label{fac:inv-tyfl-ext}
  The invariant $\tyctxrelFL{N}{R}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tyctxrelFL{N}{R}{\Psi} \implies \tyctxrelFL{N}{\Rshift{R}}{\Psi,a} & &\tyctxrelFL{N}{R}{\Psi} \implies \tyctxrelFL{N+1}{\Rext{R}}{\Psi,\Prp} \tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  \label{lem:tyr_fl_tot_pres}
  The type-relation $\tyr^R$ is left-total and preserves type formation:
  \begin{align*}
    \istyF{N}{A} \implies \mAll {R\,\Psi} \tyctxrelFL{N}{R}{\Psi} \implies \mEx a A \tyr^R a \mAnd \typingL{\Psi}{a}{\Prp}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\istyF{N}{A}$. The two binder cases use Fact~\ref{fac:inv-tyfl-ext}.
\end{proof}

For the inverse direction we establish preservation of type formation and right totality along the following invariant:
\begin{align*}
  \tyctxrelLF{N}{R}{\Psi} \eqdef \mAll {y} y\of\Prp \inL \Psi \implies \mEx x x\,R\,y \mAnd x < N
\end{align*}
\begin{fact}
  \label{fac:inv-tylf-ext}
  The invariant $\tyctxrelLF{N}{R}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tyctxrelLF{N}{R}{\Psi} \implies \typingL{\Psi}{a}{\Prp} \implies \tyctxrelLF{N}{\Rshift{R}}{\Psi,a} & &\tyctxrelLF{N}{R}{\Psi} \implies \tyctxrelLF{N+1}{\Rext{R}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  \label{lem:tyr_lf_tot_pres}
  The type-relation $\tyr^R$ is right-total and preserves type formation:
  \begin{align*}
    \typingL{\Gamma}{a}{\Prp} \implies \mAll {R\,N} \tyctxrelLF{N}{R}{\Gamma} \implies \mEx A A \tyr^R a \mAnd \istyF{N}{A}
  \end{align*}
\end{lemma}
\begin{proof}
  Induction on $\typingL{\Gamma}{a}{\Prp}$, using Fact~\ref{fac:inv-tylf-ext}.
  One complication is the disambiguation of a given PTS-product $\Prod{a} b$, where $a$ is known to live in some universe $u$.
  Discriminating on $u$ allows us to correctly choose either an arrow type $A \to B$, or a universal quantification $\All B$.
  Further requirements are the degeneracy of the universe $\Typ$ ($\Prp$ is the only inhabitant of $\Typ$), as well as propagation and substitutivity for $\tyL$.
\end{proof}

The preservation and totality results for $\tmr^R_S$ make the overhead for explicitly tracking contextual information most apparent.
Since some of the typing rules for applications ascribe types that are constructed from a non-trivial substitution operation, we require substitutivity results for the judgements under consideration; in particular, $\beta$-substitutivity for $\tyr^R$:
\begin{fact}
  The type relation $\tyr^R$ is closed under $\beta$-substitutions:
  \begin{align*}
    B \tyr^R b \implies A \tyr^{\Rext{R}} a \implies A\subst{B\scons\id} \tyr^R a\subst{b\scons\id} \tag*{\qedsymbol}
  \end{align*}
\end{fact}
The proof of this fact is a lengthy but straightforward construction that first generalises the two concrete $\beta$-substitutions to arbitrary parallel substitutions $\sigma$ and $\tau$.
The result is still not provable directly, as closure of $\tyr^R$ under weakening is needed.
This in turn is generalised to a provable statement for arbitrary renamings $\xi$ and $\zeta$ in place of $\sigma$ and $\tau$.
In essence, we establish a CML for $\tyr^R$.

We can now tackle the technically most intricate part of the proof.
The invariant for preservation of typing from F to \SysL is
\begin{align*}
  \tmctxrelFL{\Gamma}{R}{S}{\Psi} \eqdef \mAll {x A} \Gamma_x = A \implies \mEx{y a} A \tyr^R a \mAnd x\,S\,y \mAnd y \of a \inL \Psi
\end{align*}
\begin{fact}
  \label{fac:inv-tmfl-ext}
  The invariant $\tmctxrelFL{\Gamma}{R}{S}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
  &\tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies A \tyr^R a \implies \tmctxrelFL{\Gamma,A}{\Rshift{R}}{\Rext{S}}{\Psi,a} & &\tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies \tmctxrelFL{\Gamma\subst{\shift}}{\Rext{R}}{\Rshift{S}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  The term relation $\tmr^R_S$ is left-total and preserves typing.
  \begin{align*}
    \typingF{\cc{N}{\Gamma}}{s}{A} \implies &\mAll{R S \Psi} R\ms\ms\mathsf{func} \implies \tyctxrelFL{N}{R}{\Psi} \implies \tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies \\
                                            &\mEx{b a} A \tyr^R a \mAnd s \tmr^R_S b \mAnd \typingL{\Psi}{b}{a} \mAnd \typingL{\Psi}{a}{\Prp}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\typingF{\cc{N}{\Gamma}}{s}{A}$.
  Both the invariant $\tmctxrelFL{\Gamma}{R}{S}{\Psi}$, as well as Lemma~\ref{lem:tyr_fl_tot_pres}, are used to obtain related types in the variable case.
  Functionality of $R$ allows us to equate these.
\end{proof}

The final part is the preservation of typing from \SysL to F.
Here we use:
\begin{align*}
  \tmctxrelLF{\Gamma}{R}{S}{\Psi} \eqdef \mAll{y a} y \of a \inL \Psi \implies \typingL{\Psi}{a}{\Prp} \implies \mEx{x A} A \tyr^R a \mAnd x\,S\,y \mAnd x \of A \in \Gamma
\end{align*}
\begin{fact}
  \label{fac:inv-tmfl-ext}
  The invariant $\tmctxrelLF{\Gamma}{R}{S}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies A\,\tyr^R\,a \implies \tmctxrelLF{\Gamma,A}{\Rshift{R}}{\Rext{S}}{\Psi,a} & &\tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies \tmctxrelLF{\Gamma\subst{\shift}}{\Rext{R}}{\Rshift{S}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  The term relation $\tmr^R_S$ is right-total and preserves typing:
  \begin{align*}
    \typingL{\Psi}{a}{\Prp} \implies \typingL{\Psi}{b}{a} \implies &\mAll{R S N \Gamma} R\ms\ms\mathsf{inj} \implies \tyctxrelLF{N}{R}{\Psi} \implies \tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies \\
                                                                &\mEx{s A} A \tyr^R a \mAnd s \tmr^R_S b \mAnd \typingF{\cc{N}{\Gamma}}{s}{A} \mAnd \istyF{N}{A}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\typingL{\Psi}{b}{a}$.
  The cases are mostly analogue to the previous result.
  Injectivity of $R$ is required for the variable case.
  Note that we need to discriminate on the universes of product domains again (cf.\ Lemma~\ref{lem:tyr_lf_tot_pres}), here to disambiguate the unified abstractions and applications correctly.
\end{proof}

At this point we make an interesting observation.
The above proof demonstrates that the CML proof pattern not only generalises to a multi system setting~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq} but also to relations in place of functional correspondences.
This is what allowed us to quickly generate all the contextual invariants needed for the various results.

\section{Abella}
\label{sec:abella}

\newcommand{\aje}[1]{\ensuremath{\{#1\}}}
\newcommand{\aj}[2]{\ensuremath{\{#1 \vdash #2\}}}
\newcommand{\ac}[3]{\ensuremath{\mathbb{C}_{#1}^{#2} (#3)}}
\newcommand{\acFty}[1]{\ac{\mathsf{F}}{\ty}{#1}}
\newcommand{\acFtm}[1]{\ac{\mathsf{F}}{\tm}{#1}}
\newcommand{\acR}[3]{\ac{\mathsf{R}}{~}{#1 \mid #2 \mid #3}}

\begin{figure}
  \begin{center}
    \small
    \begin{mathpar}
      \mprset{andskip=2em,sep=2em}
      \inferrule*{\istyFh{A} \\ \istyFh{B}}{\istyFh{(A \to B)}} \and
      \inferrule*{\lpPi x \istyFh{x} \lpImp \istyFh{\lpApp{A}{x}}}{\istyFh{(\All{A})}} \and
      \inferrule*{\typingFh{s}{\All{B}} \\ \istyFh{A}}{\typingFh{s\,A}{\lpApp{B}{A}}} \and
      \inferrule*{\typingFh{s}{A \to B} \\ \typingFh{t}{A}}{\typingFh{s\,t}{B}}\\
      \inferrule*{\lpPi x \istyFh{x} \lpImp \typingFh{\lpApp{s}{x}}{\lpApp{A}{x}}}{\typingFh{\TyLam{s}}{\All{A}}} \and
      \inferrule*{\istyFh{A} \\ \lpPi x \typingFh{x}{A} \lpImp \typingFh{\lpApp{s}{x}}{B}}{\typingFh{\Lam A s}{A \to B}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{HOAS specification of F in Abella.\vspace{-1em}}
  \label{fig:sys-f-abella}
\end{figure}

\begin{figure}
  \begin{center}
    \small
    \begin{mathpar}
      \mprset{andskip=1.5em,sep=1.5em}
      \inferrule*{~}{\sortLh{\Typ}} \and
      \inferrule*{~}{\sortLh{\Prp}} \and
      \inferrule*{~}{\typingLh{\Prp}{\Typ}} \and
      \inferrule*{\typingLh{a}{\Prod{c}{d}} \\ \typingLh{b}{c}}{\typingLh{a\,b}{\lpApp{d}{b}}} \and
      \inferrule*{\typingLh{a}{u} \\ \sortLh{u} \\ \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{b}{x}}{\Prp}}{\typingLh{\Prod{a}{b}}{\Prp}} \and
      \inferrule*{\typingLh{a}{u} \\ \sortLh{u} \\  \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{c}{x}}{\Prp} \\ \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{b}{x}}{\lpApp{c}{x}}}{\typingLh{\Lam{a}{b}}{\Prod{a}{c}}}
    \end{mathpar}
    \vspace{-2.5em}
  \end{center}
  \caption{HOAS specification of \SysL in Abella.\vspace{-1em}}
  \label{fig:sys-l-abella}
\end{figure}

%\enlargethispage{\baselineskip}

Abella supports the use of higher-order abstract syntax (HOAS)~\cite{DBLP:conf/pldi/PfenningE88}.
The main idea is to delegate variable binding at the object level to binding at the meta level.
Take for example the term constructor $\mathsf{lam} \OF (\mathsf{tm} \to \mathsf{tm}) \to \mathsf{tm}$ that yields an abstraction of the untyped $\lambda$-calculus.
The $s$ in $\mathsf{lam}\,s$ is a function of the meta level.
Substitution at the object level is implemented as application at the meta level, which we denote by $\lpApp{s}{t}$ to distinguish it from the various object level applications.

Reasoning about HOAS encodings inductively is somewhat complicated, as terms do not remain closed and escape into the host theory.
To get around this, Abella is designed around the so-called two-level logic approach.
The lower \emph{specification level}, essentially verbatim $\lambda$Prolog, is used to encode the object languages and their associated judgements.
One then reasons about these encodings at the \emph{meta level}, using the logic $\mathcal{G}$, which is the intuitionistic predicative fragment of Church's simple type theory, extended with natural induction, (co)inductive predicates and nominal quantification ($\nabla x . \ms s$).
The axioms of $\mathcal{G}$ ensure that a $\nabla$-quantified identifier is fresh for everything bound above it.
The faithful representation of object level variables relies on these freshness guarantees.

The two levels are connected with a special inductive predicate that embeds the derivation of a $\lambda$Prolog judgement $J$ from hypotheses $L = I_0,\ldots,I_n$ into $\mathcal{G}$, written $\aj{L}{J}$, or simply $\aje{J}$ in the absence of assumptions.
Note that $\lambda$Prolog supports hypothetical ($J_1 \lpImp J_2$) and locally quantified ($\lpPi{x} J\subst{x}$) premises, which the embedding treats as follows:
\begin{align*}
  \aj{L}{J_1 \lpImp J_2} &\quad\leadsto\quad \aj{L, J_1}{J_2} & \aj{L}{\lpPi{x} J\subst{x}}&\quad\leadsto\quad \nabla x. \aj{L}{J\subst{x}}
\end{align*}

For the quantification case, observe that the context $L$ is usually bound at the outermost level, hence $x$ is guaranteed to be fresh for $L$, satisfying the usual side condition for context extension rules.
This process is often referred to as \emph{mobility of binders}: object level binders are represented using $\lambda$Prolog quantification, which in turn is mapped to $\nabla$-quantification in~$\mathcal{G}$ and eventually opened with nominal constants $n_i$.
\begin{fact}
  \label{fac:ab-cut-inst}
  The embedding $\aj{L}{J}$ satisfies cut and a nominal instantiation principle:
  \begin{align*}
    &\aj{L}{I} \implies \aj{L,I}{J} \implies \aj{L}{J} \tag{cut} \\
    &\mAll{s \of \mathsf{typeof}\, n_i} \aj{L\subst{n_i}}{J\subst{n_i}} \implies \aj{L\subst{s}}{J\subst{s}} \tag{inst}
  \end{align*}
  Both are exposed as proof tactics to the user.\hfill\qedsymbol
\end{fact}
Note that Fact~\ref{fac:ab-cut-inst} provides substitutivity for the various judgements of our object languages.
It is also worth noting that only the judgements, but not the specification level types like~$\TmL$ and $\TyF$, are embedded, so we cannot induct directly on our syntax definitions.

At this point it should be straightforward to understand the HOAS representation of our two systems given in Figures~\ref{fig:sys-f-abella}~and~\ref{fig:sys-l-abella}.\footnote{The HOAS language definitions are as one would expect. See also Appendix~\ref{apdx:hoas} for reference.}
For F, the judgements $\istyFh{A}$ and $\typingFh{s}{A}$ encode type formation and respectively typing.
For \SysL, the judgement $\sortLh{u}$ is used to recognise universes, while $\typingLh{a}{b}$ represents PTS typing.

As soon as we try to prove structural results about these definitions we are faced with a problem.
Consider the following inversion principle for arrow type formation in F:
\begin{align*}
  \aj{L}{\istyFh{A \to B}} \implies \aj{L}{\istyFh{A}} \mAnd \aj{L}{\istyFh{B}}
\end{align*}

The premise may hold not only due to structural reasons, as claimed by the lemma, but also due to backchaining and $\istyFh{A \to B} \in L$.
The problem is that $L$ is too general and may contain arbitrary judgements, not even necessarily related to type formation.
Hence we need to somehow constrain $L$ to only contain judgements of the form~$\istyFh{n_i}$, where the $n_i$ are nominals representing variables.
Similarly we want to constrain typing contexts to only contain judgements of the form $\istyFh{n_i}$ or $\typingFh{n_i}{A}$.
We specify this notion of well-formed contexts  with auxiliary inductive $\mathcal{G}$-predicates.
The well-formedness predicate for F typing contexts, written $\acFtm{-}$, is defined as:

\vspace{-.5em}
{\small
\begin{mathpar}
  \inferrule*{~}{\acFtm{\emptyctx}} \and
  \inferrule*[right=$x \notin L$]{\acFtm{L}}{\acFtm{L,\istyFh{x}}}\and
  \inferrule*[right={$x \notin L,A$}]{\acFtm{L} \\ \aj{L}{\istyFh{A}}}{\acFtm{L,\typingFh{x}{A}}}
\end{mathpar}
}\vspace{-1em}

The freshness conditions are implemented by locally $\nabla$-quantifying the respective variable.
Next we have to pair this definition with an inversion principle that reveals the structure and freshness properties of any $J \in L$ with $\acFtm{L}$.
At this point we are able to add $\acFty{L}$, defined analogously to $\acFtm{L}$, as an extra premise to our inversion principle and then discard the spurious context extraction.
This relies on the fact that $\nabla x . (A \to B) \neq x$ holds in $\mathcal{G}$.
A key aspect of formalising our equivalence result in Abella is the correct choice of well-formedness predicates and associated inversion lemmas.

{\bf The second equivalence proof.}
The relations $\tyr$ and $\tmr$ are defined as:

\vspace{-.5em}
{\small
\begin{mathpar}
  \mprset{andskip=1.5em,sep=1.5em}
  \inferrule*{A \tyr a \\ \lpPi {x} B \tyr \lpApp{b}{x}}{A \to B \tyr \Prod a b} \and
  \inferrule*{\lpPi{x y} x \tyr y \lpImp \lpApp{A}{x} \tyr \lpApp{a}{y}}{\All A \tyr \Prod \Prp a} \and
  \inferrule*{s \tmr a \\ t \tmr b}{s\,t \tmr a\,b} \and
  \inferrule*{A \tyr a \\ \lpPi{x y} x \tmr y \lpImp \lpApp{s}{x} \tmr \lpApp{b}{y}}{\Lam A s \tmr \Lam a b} \and
  \inferrule*{\lpPi{x y} x \tyr y \lpImp \lpApp{s}{x} \tmr \lpApp{a}{y}}{\TyLam s \tmr \Lam \Prp a} \and
  \inferrule*{s \tmr a \\ A \tyr b}{s\,A \tmr a\,b}
\end{mathpar}
}\vspace{-1em}

We complement this definition with a well-formedness predicate $\ac{\tmr}{~}{L}$, which ascertains that $L$ only contains judgements of the form $n_i \tyr n_j$ or $n_i \tmr n_j$, together with suitable lookup lemmas.
For technical reasons we do not define $\ac{\tyr}{~}{-}$ and instead prove a strengthening lemma which holds due to the inferred subordination ordering of the two relations:
\begin{align*}
  \ac{\tmr}{~}{L} \implies \aj{L, x \tmr y}{A \tyr a} \implies \aj{L}{A \tyr a}
\end{align*}

Before we go on, it is interesting to consider the information encapsulated in $\ac{\tmr}{~}{L}$.
The obvious part is that $L$ contains exactly the same information about corresponding variables that we had to track in Coq with the auxiliary parameters $R$ and $S$.
In addition, since $L$ only contains pairings of fresh nominals, we immediately obtain that $L$ is functional and injective.
Lifting these properties to $\tyr$ and then to $\tmr$ are routine inductions.

When it comes to the totality and preservation statements, things become more interesting.
The remaining four lemma statements are generalised over three different contexts belonging to the three involved judgements.
Not only do we require these contexts to be locally well-formed, but we also have to connect them.
We achieve this with a single ternary well-formedness predicate, $\acR{-}{-}{-}$, defined as follows:

\vspace{-.5em}
{\small
\begin{mathpar}
  \mprset{andskip=.8em,sep=1em}
  \inferrule*{~}{\acR{\emptyctx}{\emptyctx}{\emptyctx}} \and
  \inferrule*{\acR{L_{\mathsf{F}}}{L_{\tmr}}{L_{\lambda}} \\ x, y \notin L_{i}}{\acR{L_{\mathsf{F}}, \istyFh{x}}{L_{\tmr}, x \tyr y}{L_{\lambda}, \typingLh{y}{\Prp}}} \and
  \inferrule*{\acR{L_{\mathsf{F}}}{L_{\tmr}}{L_{\lambda}} \\ x, y \notin L_{i},A,a \\\\ \aj{L_{\mathsf{F}}}{\istyFh{A}} \\ \aj{L_{\tmr}}{A \tyr a} \\ \aj{L_{\lambda}}{\typingLh{a}{\Prp}}}{\acR{L_{\mathsf{F}}, \typingFh{x}{A}}{L_{\tmr}, x \tmr y}{L_{\lambda}, \typingLh{y}{a}}}
\end{mathpar}
}\vspace{-1em}

When a binder is traversed, this ensures that all three contexts are extended with the same freshly chosen variables $x$ and $y$.
The definition is accompanied by three extraction lemmas, one for each of the three involved contexts, which provide the associated judgements from the two other contexts.
Recall that in Coq we had four separate invariants for the four preservation and totality lemmas.
Here, this information is uniformly encoded in~$\acR{L_{\mathsf{F}}}{L_{\tmr}}{L_{\lambda}}$ and we use it for all four proofs.
\begin{lemma} The type relation $\tyr$ is total from F to \SysL and preserves type formation.
  \begin{align*}
    \aj{L_{\mathsf{F}}}{\istyFh{A}} \implies \mAll{L_{\tmr}L_{\lambda}} \acR{L_{\mathsf{F}}}{L_{\tmr}}{L_{\lambda}} \implies \mEx{a} \aj{L_{\tmr}}{A \tyr a} \mAnd \aj{L_{\lambda}}{\typingLh{a}{\Prp}}
\end{align*}
\end{lemma}
\begin{proof}
  By induction on $\aj{L_{F}}{\istyFh{A}}$.
\end{proof}
As a trivial corollary we obtain: $\aje{\istyFh{A}} \implies \mEx{a} \aje{A \tyr a} \mAnd \aje{\typingLh{a}{\Prp}}$.

The proofs of the remaining three preservation results are surprisingly analogue, so we will not go into further detail.
It is worth pointing out, though, that we again require the degeneracy of the PTS universe $\Typ$, as well as propagation for both F and \SysL in various places.
The HOAS setup allows us to obtain these easily.

\section{Beluga}
\label{sec:beluga}

\newcommand{\D}{\mathcal{D}}
\newcommand{\bc}[2]{\ensuremath{[\,#1\,\vdash #2\,]}}
\newcommand{\sof}{\ensuremath{\!:\ms}}
\newcommand{\ssep}{\ensuremath{,\ms}}

The programming and proof environment Beluga~\cite{Pientka:FLOPS10,Pientka:CADE15} is another system that supports HOAS.
Object languages are encoded in the logical framework LF~\cite{Harper93jacm}, while proofs about these are expressed as total programs in contextual modal type theory, Beluga's reasoning logic.
The programs analyse LF derivation trees using pattern matching and higher-order unification.
In Beluga, it is necessary to give programs (i.e.\ proof terms) explicitly, which are proof checked as part of type checking.
This stands in contrast to Coq and Abella, both of which are interactive systems with a tactic language for proof term construction.

%\enlargethispage{\baselineskip}

The biggest difference, however, lies with Beluga's treatment of object level variables.
In particular, at the outermost level, there is no such thing as a free object variable.
This is in stark contrast to Coq's dangling de Bruijn indices and Abella's global nominal constants.
In Beluga we instead deal with \emph{contextual objects}, written $\bc{\Gamma}{K}$, that is objects $K$ (like types, terms, typing derivations) paired with contexts $\Gamma$ in which they are meaningful~\cite{Nanevski:ICML05,Pientka:POPL08}.
One of the main advantages of contextual objects is, that they remain closed under inductive reasoning.
Hence they constitute an alternative to Abella's two-level logical embedding.

As an example, consider the function type $X \to X$ where $X$ is a free type variable.
This function type is ill-formed under the empty type variable context $\Delta = \emptyset$.
In Coq and Abella we can express this type, as $0_\ty \to 0_\ty$ and respectively $n_0 \to n_0$.
We can then show that assuming well-formedness under the empty context entails absurdity, $\istyF{0}{0_\ty \to 0_\ty} \implies \bot$ and $\aj{\emptyctx}{\istyFh{n_0 \to n_0}} \implies \bot$.
Meanwhile in Beluga, we observe that the contextual object $\bc{\emptyctx}{x \to x}$ is not even syntactically well-formed, since $x \notin \emptyctx$.
An immediate consequence of this is that the type formation judgement for F, which ensures that the context is covering all free type variables, becomes redundant.
Hence Beluga's definition of F is obtained from Figure~\ref{fig:sys-f-abella} by removing all references to type formation.
The definition of \SysL is identical to the one for Abella (Figure~\ref{fig:sys-l-abella}).\footnote{For a concrete presentation of the resulting definitions, see Appendix~\ref{apdx:hoas}.}

Recall that context management was completely manual in Coq.
Each judgement required well-chosen generalisations and custom invariants to accurately track contextual information.
In Abella the situation was noticeably better, as contexts at the object level were kept implicit and handled by the system.
At the reasoning level they did, however, surface as explicit, unstructured sequences of judgements.
The desired contextual structure then had to be imposed with auxiliary predicates, together with copious amounts of inversion lemmas.

Beluga contexts, on the other hand, are sequences of not necessarily homogeneous declarations.
Each declaration can depend on prior declarations and encapsulate multiple pieces of related information using a dependent record.
Contexts are first class citizens and \emph{context schema} ascription, $\Gamma \OF S$, is used to ensure that a given context $\Gamma$ satisfies certain structural constraints.

Schemas are Beluga's main device to enforce invariants on contextual information.
We use propagation for \SysL as an example.
The requisite schema is:
\begin{align*}
  S_{\lambda W} \eqdef [x\sof\TmL \ssep \typingLh{x}{\Prp}] + [x\sof\TmL \ssep \typingLh{x}{a} \ssep \typingLh{a}{\Prp}]
\end{align*}

Note how it separates PTS variables into type and term variables via the associated typing information, which already imposes the necessary semantic contextual information.
The proof of propagation is straightforward.
We implement a total recursive function $k$ satisfying:
\begin{align*}
  k \OF \mAll{\Gamma \of S_{\lambda W}} \bc{\Gamma}{\typingLh{a}{b}} \implies \bc{\Gamma}{\mathsf{type\_correct}\,b}
\end{align*}

The contextual predicate $\bc{\Gamma}{\mathsf{type\_correct}\,b}$ encodes that $b$ is either $\Typ$ or it can be typed with some universe $u$.
We pattern match $\D \OF \bc{\Gamma}{\typingLh{a}{b}}$ and obtain seven cases.
The first four are structural, recursively descending into sub-derivations.
The only part that is non-obvious is the traversal of binders, where various pieces of information are added to the context.
These have to be packaged into declaration blocks in order to satisfy $S_{\lambda W}$ for the recursive call.
More interesting though are the three base cases.
When we compare the matched type against $S_{\lambda W}$, we observe three ways in which $\D$ could have been obtained from the context.
The first and third are trivial as they unify $b$ with $\Prp$ which can be typed with the universe $\Typ$.
For the remaining case we know that $b$ can be typed with the universe~$\Prp$, contextual information that was packaged together with the matched judgement.
Note that throughout the construction we exploit that Beluga natively supports substitution into parametric sub-derivations.

{\bf The third equivalence proof.}
The definitions of $\tyr$ and $\tmr$ exactly coincide with Abella.
We are going to primarily concern ourselves with the schemas, which best illustrate Beluga's tracking of contextual information.

We begin with the functionality and injectivity properties of $\tyr$ and $\tmr$.
Since equality is not native in Beluga we have to define equality predicates for each syntactic sort to express our statements. The tightest invariants that hold for the rules defining $\tyr$ and $\tmr$ can be expressed with the following context schemas:
\begin{align*}
  S_{\tyr} &\eqdef [x\sof\TyF \ssep y\sof\TmL \ssep x \tyr y] + [y\sof\TmL]\\
  S_{\tmr} &\eqdef [x\sof\TyF \ssep y\sof\TmL \ssep x \tyr y] + [x\sof\TmF \ssep y\sof\TmL \ssep x \tmr y]
\end{align*}

Due to the subordination ordering of $\tyr$ and $\tmr$, Beluga is capable of automatically strengthening from $S_{\tmr}$ to $S_{\tyr}$, and weaken vice versa (see also~\cite{Virga99phd}).
\begin{lemma}
  There exist total recursive functions $f_{\ty}, f_{\tm}, i_{\ty}$ and $i_{\tm}$, satisfying
  \begin{align*}
    f_{\ty} &\OF  \mAll{\Gamma \of S_{\tyr}} \bc{\Gamma}{A \tyr a} \implies \bc{\Gamma}{A \tyr a'} \implies \bc{\Gamma}{a =_{\lambda} a'}\\
    i_{\ty} &\OF  \mAll{\Gamma \of S_{\tyr}} \bc{\Gamma}{A \tyr a} \implies \bc{\Gamma}{A' \tyr a} \implies \bc{\Gamma}{A =^{\ty}_{\mathsf{F}} A'}\\
    f_{\tm} &\OF  \mAll{\Gamma \of S_{\tmr}} \bc{\Gamma}{s \tmr a} \implies \bc{\Gamma}{s \tmr a'} \implies \bc{\Gamma}{a =_{\lambda} a'}\\
    i_{\tm} &\OF  \mAll{\Gamma \of S_{\tmr}} \bc{\Gamma}{s \tmr a} \implies \bc{\Gamma}{s' \tmr a} \implies \bc{\Gamma}{s =^{\tm}_{\mathsf{F}} s'}
\end{align*}
\end{lemma}
\begin{proof}
  Each by induction on the first premise and pattern matching on the second.
  In the variable cases we have matched against two context records $r$ and $r'$.
  Since $x$ and $y$ are local to $r$ and one of them is shared between the two matched records, unification infers $r = r'$, closing the case.
  Note that $f_{\tm}$ and $i_{\tm}$ contain calls to $f_{\ty}$ and respectively $i_{\ty}$, which relies on context strenghtening.
  For $i_{\tm}$ we also again require disjointedness of the two relations, which is easily obtainable under contexts satisfying $S_{\tmr}$.
\end{proof}

For the remaining four totality and preservation proofs we have to deal with two complications.
First, we have to remove assumptions and conclusions referring to F type formation.
Second, we have to define predicates that capture the existential nature of the four conclusions, including relevant typing information, with custom predicates.
We have, for example,
\begin{align*}
  \mathsf{exists\_rel\_proof}\,s\,A \iff \mEx{ba} s \tmr b \mAnd A \tyr a \mAnd \typingLh{b}{a} \mAnd \typingLh{a}{\Prp}
\end{align*}
The required context schemas are quite involved:
\begin{align*}
  S_{\tyr W}^{\rightarrow} \eqdef &[x\sof\TyF \ssep y\sof\TmL \ssep x \tyr y \ssep \typingLh{y}{\Prp}] + [y\sof\TmL \ssep \typingLh{y}{a}]\\
  S_{\tyr W}^{\leftarrow} \eqdef &[x\sof\TyF \ssep y\sof\TmL \ssep x \tyr y \ssep \typingLh{y}{\Prp}] + [y\sof\TmL \ssep \typingLh{y}{a} \ssep A \tyr a \ssep \typingLh{a}{\Prp}]\\
  S_{\tmr W} \eqdef &[x\sof\TyF \ssep y\sof\TmL \ssep x \tyr y \ssep \typingLh{y}{\Prp}] + [x\sof\TmF \ssep y\sof\TmL \ssep x \tmr y \ssep \typingFh{x}{A} \ssep \typingLh{y}{a} \ssep A \tyr a]
\end{align*}
\begin{lemma}
  There exist total recursive functions $p^{\rightarrow}_{\tyr},p^{\leftarrow}_{\tyr},p^{\rightarrow}_{\tmr}$ and $p^{\leftarrow}_{\tmr}$, satisfying
  \begin{align*}
    p^{\rightarrow}_{\tyr} &\OF  \mAll{\Gamma \of S_{\tyr W}^{\rightarrow}} \mAll{A \of \bc{\Gamma}{\TyF}} \bc{\Gamma}{\mathsf{exists\_rel\_prop}\,A}\\
    p^{\leftarrow}_{\tyr} &\OF \mAll{\Gamma \of S_{\tyr W}^{\leftarrow}} \bc{\Gamma}{\typingLh{a}{\Prp}} \implies \bc{\Gamma}{\mathsf{exists\_rel\_type}\,a}\\
    p^{\rightarrow}_{\tmr} &\OF \mAll{\Gamma \of S_{\tmr W}} \bc{\Gamma}{\typingFh{s}{A}} \implies \bc{\Gamma}{\mathsf{exists\_rel\_proof}\,s\,A}\\
    p^{\leftarrow}_{\tmr} &\OF \mAll{\Gamma \of S_{\tmr W}} \bc{\Gamma}{\typingLh{b}{a}} \implies \bc{\Gamma}{\typingLh{a}{\Prp}} \implies \bc{\Gamma}{\mathsf{exists\_rel\_term}\,b\,a}
  \end{align*}
\end{lemma}
\begin{proof}
  The first is by induction on $A \of \bc{\Gamma}{\TyF}$ (recall that this was not possible in Abella), the others are by induction on the first premise.
  The proofs are quite technical but mostly straightforward.
  The construction of $p^{\leftarrow}_{\tmr}$, needs \SysL propagation.
  Interestingly, neither propagation in F nor the degeneracy of $\Typ$ are needed, as unification automatically handles the respective occurrences.
\end{proof}

\begin{wrapfigure}{r}{0.25\textwidth}
  \centering
  \begin{tikzpicture}
    \node (a1) at (0,3.5) [rectangle,draw] {$S_{\tyr}$};
    \node (a2) at (1.5,2.5) [rectangle,draw] {$S_{\tmr}$};
    \node (a3) at (0,2) [rectangle,draw,dashed] {$S_{\tyr W}^{\rightarrow}$};
    \node (a4) at (0,1) [rectangle,draw,dashed] {$S_{\tyr W}^{\leftarrow}$};
    \node (a5) at (1.5,0) [rectangle,draw,dashed] {$S_{\tmr W}$};
    \draw (a1) -- (a2);
    \draw (a2) -- (a5);
    \draw (a1) -- (a3);
    \draw (a3) -- (a4);
    \draw (a4) -- (a5);
  \end{tikzpicture}
  \vspace{-0.5em}
  \caption{Hierarchy of Context Schemas}
  \label{fig:ctxschema}
\end{wrapfigure}

The most interesting part of the Beluga development appears to be the particularly rich structure and interdependencies of the various schemas.
We would like to point out in particular, that while the schemas $S_{\tyr}$ and $S_{\tmr}$ could likely be inferred automatically by inspecting the involved type families, this does not appear to work for those schemas with auxiliary well-typedness assumptions (subscript $W$).
This contradicts the common belief that schema inference should in principle always be possible.

The schemas can be further arranged in a hierarchy (Figure~\ref{fig:ctxschema}).
A context satisfying $S_{\tyr}$ can always be weakened to one sitting lower in the hierarchy.
The hierarchy also induces a strengthening relationship, going upwards, as long as the subordination order of judgements under said contexts is respected.

\section{A Note on Adequacy}
\label{sec:adequacy}

Any form of formalised reasoning raises the question of the faithfulness of the formal representation.
Do the formal definitions correspond to the intuitively understood mathematical objects that we want to reason about?
For the special case of syntactic systems and their meta theory, this particular property is called \emph{adequacy} and expresses that the on-paper syntax and the formal encoding are in one-to-one correspondence.
It should be clear that adequacy has to be argued outside the proof system in question, as it relates a formal encoding to an intuitive concept.

We have just covered three formalisations that all encode syntax, so let us consider each of them in the light of adequacy.

In Coq we have a pure de Bruijn setup, a first-order encoding.
Since all structures are defined and manipulated explicitly, and first-order encodings are generally well understood, there is not much doubt in the faithfulness of the representation.
In particular, the main feature of our host system that is used heavily is the notion of an inductive type, and it is commonly agreed that the grammar of a language is an inductive structure.

For the higher-order encodings used in Abella and Beluga the situation is quite different, as both are intertwined with their respective host systems.
The biggest issue here are the object level function spaces which are directly obtained form the host system function spaces.
The same holds for substitution which is also borrowed from the host environmnet.

For basic HOAS these issues have been extensively discussed since at least the 90s and it is widely assumed that the resulting adequacy proofs are acceptable.
This pertains to our syntax definitions as well.
When it comes to the judgements though, it gets slightly more interesting, as both in Abella and Beluga, we use features that go beyond basic HOAS, namely subordination, which allows us to ignore certain cases in the proofs.
So why do we trust the results here?

Mostly because they do not break under close scrutiny.
That is, we managed to prove several expected properties for the given definitions.
More importantly each of the proofs connects two variants of presumably the same intuitive mathematical entity.
Last, and probably most relevant, is the fact that the same large scale proof design that worked for the de Bruijn encoding could be replayed for both HOAS representations.
In combination this should suggest adequacy until evidence to the contrary is provided.

\section{Conclusion}
\label{sec:conclusion}

We have considered a technically interesting proof and demonstrated how various formalisation techniques deal with the arising intricacies.
The development of three different formalisations allowed us to gain deep insights into the inherent complexities of the proof.
In particular we were able to separate these from technical artefacts due to the chosen formalisation technique.
Two examples of inherent complications are the not quite perfectly aligned binding structures and the missing typing information required to disambiguate the uniform PTS applications.

Our set of developments demonstrates, that the various formalisation techniques can be arranged in a hierarchy of abstraction layers.
At the lowest level we have pure de Bruijn with a lot of representation freedom, which, however, has to be manged manually.
Higher up in the hierarchy sit the HOAS techniques, which hide a lot of the technicalities and provide a more meaningful abstraction.
In comparison with Abella, Beluga appears to deliver the theoretically nicer interface, with the added features of contextual reasoning and the ability to perform inductions directly over the HOAS syntax.
Practically though, both systems are relatively young with certain usability issues.
Among the two, Abella's tactic language certainly gives it a head start.

We observe that our proof contains a number of challenges that, taken as a whole, constitute a nice benchmark for systems designed to reason about type systems.
It tests in particular, how well multiple type systems with binding constructs can be brought into correspondence.
We hence propose it as a complement to the POPLmark challenge~\cite{poplmark} on the one hand, which solely tests how well a system can reason about a single type system, and the ORBI benchmarks~\cite{Felty:ITP10,Felty:orbi-survey} which cover small-scale contextual reasoning.
It is our belief that such a benchmark could be very useful to those who seek to develop or improve frameworks for reasoning about type systems and similar syntactic systems with variable binding and complex contextual information.

We have come to the conclusion that, as so often, there appears to be no ``silver bullet'' solution.
There exist various approaches and they all have their merits and drawbacks.
The question is not so much about whether de~Bruijn or HOAS is better, but what techniques pair well with each approach.
Take for example the parallel substitutions and the notion of context morphism lemmas that elegantly complement de~Bruijn syntax.
Meanwhile in Abella we had the two-level logic approach and the crucial part was the definition of suitable inversion principles.
Finally we had Beluga and its first class contexts where the various context schemas played the essential role.
There are of course other approaches (see below), but a comprehensive survey, while desirable, would certainly exceed the scope of this format.
We hope that our work constitutes a small step towards such a catalogue of techniques.
We also suggest to everyone who works with formalisations of binding syntax to seriously consider at least one alternative approach as the process can be quite enlightening.

\noindent{\bf Future Work.}
We would like to continue into three largely orthogonal directions.

First, we would like to widen the scope of the benchmark itself and include a correspondence result for the computational behaviour of the two systems.
Equi-reducebility is at least as interesting a problem as equi-typability, and likely to pose its own set of challenges.
One of these is the fact that, prior to typing, \SysL has a lot more $\beta$-redices than its two-sorted counterpart, hence some form of typing information will have to be tracked along with the relational assumptions.
This will lead to new forms of contexts that are likely comparable in complexity to those discussed here.

Second, we would like to test further frameworks against our benchmark.
One candidate is the locally nameless approach~\cite{DBLP:conf/popl/AydemirCPPW08}.
It provides an abstraction layer that sits somewhere between pure de Bruijn and HOAS.
Our benchmark could test the stability of this layer.
Another is the HYBRID framework~\cite{DBLP:journals/jar/FeltyM12} that aims to bring HOAS to Coq.
At present however, it is neither equipped with Abella's $\nabla$ nor Beluga's contextual types, so it remains to be seen if it can handle our challenge.
Another reason why the HYBRID approach is interesting, if it should turn out to be feasible, is the fact that it also exists as an Isabelle library and hence would allow an extension of the benchmark in that direction.
It would also be interesting to see how a system like Twelf~\cite{DBLP:conf/cade/PfenningS99} would handle the rich context structures.

Finally, we consider scaling the challenge both down to the simply typed $\lambda$-calculus, as well as up to F$_\omega$, to obtain a better understanding of where exactly certain complications originate from.

\appendix

\section{De~Bruijn Definitions}
\label{apdx:db}

We recap the core concepts of de Bruijn with parallel substitutions.
The main feature of de Bruijn syntax is the absence of variable names, yielding concrete canonical representations for the on-paper implicitly assumed $\alpha$-equivalence classes of syntactic expressions.
Instead of using names, variables are represented as numerical indices, where $n$ references the $n$-th enclosing binder of the corresponding scope.
We illustrate the concepts using the two-sorted variant of System~F that is discussed in the main text:
\begin{align*}
  A, B &\bnfdef x_\ty \mid A \to B \mid \All A & s, t &\bnfdef x_\tm \mid s\,t \mid \Lam A s \mid s\,A \mid \TyLam s & &x \OF \Nat
\end{align*}
Note that the $A$ in $\Lam A s$ is the type of the bound term variable, not its name.
Dangling references correspond to free variables.
They are taken as indices into an ambient context which is normally represented as a list of the information attached to each variable.
A standard typing context $\Gamma$ is represented as a simple list of types.

To understand the instantiation of terms or types with parallel substitutions, let us first recall a few primitives of the $\sigma$-calculus (see~\cite{abadi1991} for details):
\begin{align*}
  (M \scons \sigma)\,0 &\eqdef M & \shift\,x&\eqdef (x + 1)\\
  (M \scons \sigma)\,(x + 1) &\eqdef \sigma\,x & \id &\eqdef 0 \scons \shift
\end{align*}
Parallel substitutions $\sigma \OF \Nat \to \mathcal{T}$, where $\mathcal{T}$ is some syntactic sort, can be seen as streams $M_0, M_1, \ldots $, with $M_i \OF \mathcal{T}$.
This motivates the notion of the \emph{cons} operation $M \scons \sigma$, which maps the index 0 to $M$, and all other indices $x + 1$ to $\sigma\,x$.
The \emph{shift} operation simply raises all indices by one, and the identity substitution $\id$ is a derived notion.
The concrete type of substitutions and a corresponding instance of this framework depends on the syntactic sort for which a notion of substitution is defined.

Let us first consider the types of our example.
The instantiation of a type $A$ with a parallel substitution $\sigma$, written $A\subst\sigma$, is defined mutually recursive with the forward composition of parallel substitutions.
\begin{align*}
  x_\ty\subst\sigma &= \sigma\,x_\ty & (\sigma_1 \scomp \sigma_2)\,x_\ty &= (\sigma_1\,x_\ty)\subst{\sigma_2}\\
  (A\to B)\subst\sigma &= A\subst\sigma \to B\subst\sigma & &\\
  (\All A)\subst\sigma &= \All A\subst{\up\sigma} & \text{with } \up\sigma&= 0_\ty \scons \sigma \scomp \shift
\end{align*}
For the terms we actually require a vector of two parallel substitutions, $\langle\sigma,\tau\rangle$, since both type and term variables can occur in a given term:
\begin{align*}
  x_\tm\subst{\sigma,\tau} &= \tau\,x_\tm & (\sigma' \scomp \langle\sigma,\tau\rangle)\,x_\tm &= (\sigma'\,x_\tm)\subst{\sigma,\tau}\\
  (s\,t)\subst{\sigma,\tau} &= s\subst{\sigma,\tau}\,t\subst{\sigma,\tau} & &\\
  (\Lam A s)\subst{\sigma,\tau} &= \Lam {A\subst\sigma} {s\subst{\up^{\tm}\langle\sigma,\tau\rangle}} & \text{with } \up^{\tm}\langle\sigma,\tau\rangle &= \langle\sigma,0_\tm\scons\tau\scomp{\langle\id,\shift\rangle}\rangle\\
  (s\,A)\subst{\sigma,\tau} &= s\subst{\sigma,\tau}\,A\subst{\sigma} & &\\
  (\TyLam s)\subst{\sigma,\tau} &= \TyLam {s\subst{\up^{\ty}\langle\sigma,\tau\rangle}} & \text{with } \up^{\ty}\langle\sigma,\tau\rangle&= \langle 0_\ty \scons \sigma \scomp \shift, \tau \scomp \langle\shift,\id\rangle\rangle
\end{align*}

The key idea in both cases is that parallel substitutions act on all free variables at once, which leads to an elegant equational theory and subsequently to a good foundation for proof automation.
A nice example is $\beta$-substitutivity, which can concisely be expressed as $(\Lam A s)\,t\leadsto s\subst{\id,t\scons\id}$.

The Autosubst framework is capable of generating all of this automatically from annotated inductive syntax definitions, together with the respective equational theories.
It further provides a decision tactic that can solve goals involving substitution expressions, based on the results in~\cite{SchaeferEtAl:2009:Completeness}.

\section{HOAS Definitions}
\label{apdx:hoas}

We give a brief overview of the definitions as they were used in the Abella and Beluga proofs.
The HOAS specifications are identical for both systems.
The two-sorted variant is given on the left, the PTS is on the right.
We also include the types of the judgements.

\newcommand{\ET}{\ensuremath{\_}}
\begin{align*}
  \TyF, \TmF &\OF \Type & \TmL &\OF \Type\\
  \cline{1-4}
  & & \Prp, \Typ &\OF \TmL \\
  \ET \to \ET &\OF \TyF \to \TyF \to \TyF & \Prod \ET \ET &\OF \TmL \to (\TmL \to \TmL) \to \TmL\\
  \All \ET &\OF (\TyF \to \TyF) \to \TyF & &\\
  \ET\,\ET &\OF \TmF \to \TmF \to \TmF & \ET\,\ET &\OF \TmL \to \TmL \to \TmL\\
  \ET\,\ET &\OF \TmF \to \TyF \to \TmF & &\\
  \Lam \ET \ET &\OF \TyF \to (\TmF \to \TmF) \to \TmF & \Lam \ET \ET &\OF \TmL \to (\TmL \to \TmL) \to \TmL\\
  \TyLam \ET &\OF (\TyF \to \TmF) \to \TmF & &\\
  \cline{1-4}
  \istyFh \ET &\OF \TyF \to \Prop & \sortLh \ET &\OF \TmL \to \Prop\\
  \typingFh \ET \ET &\OF \TmF \to \TyF \to \Prop & \typingLh \ET \ET &\OF \TmL \to \TmL \to \Prop
\end{align*}
Note that Abella distinguishes the system sorts $\Prop$ and $\Type$.
Inductive derivations are only exposed for the former.
In Beluga on the other hand, both are considered as basic LF types.

The four judgements/predicates are defined inductively, both in Abella and Beluga.
The two PTS definitions are identical in both frameworks.
The bold operators $\lpImp$ and $\lpPi \ET \ET$  are used to construct hypothetical and locally quantified premises, respectively.
Meta level application is denoted by $\lpApp \ET \ET$.
\begin{mathpar}
  \mprset{andskip=1.5em,sep=1.5em}
  \inferrule*{~}{\sortLh{\Typ}} \and
  \inferrule*{~}{\sortLh{\Prp}} \and
  \inferrule*{~}{\typingLh{\Prp}{\Typ}} \and
  \inferrule*{\typingLh{a}{\Prod{c}{d}} \\ \typingLh{b}{c}}{\typingLh{a\,b}{\lpApp{d}{b}}} \and
  \inferrule*{\typingLh{a}{u} \\ \sortLh{u} \\ \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{b}{x}}{\Prp}}{\typingLh{\Prod{a}{b}}{\Prp}} \and
  \inferrule*{\typingLh{a}{u} \\ \sortLh{u} \\  \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{c}{x}}{\Prp} \\ \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{b}{x}}{\lpApp{c}{x}}}{\typingLh{\Lam{a}{b}}{\Prod{a}{c}}}
\end{mathpar}

With respect to the two-sorted system there is a difference between the Abella and the Beluga definitions, due to the differences in the respective meta theories.
The Abella version is straightforward:
\begin{mathpar}
  \mprset{andskip=2em,sep=2em}
  \inferrule*{\istyFh{A} \\ \istyFh{B}}{\istyFh{(A \to B)}} \and
  \inferrule*{\lpPi x \istyFh{x} \lpImp \istyFh{\lpApp{A}{x}}}{\istyFh{(\All{A})}} \and
  \inferrule*{\typingFh{s}{\All{B}} \\ \istyFh{A}}{\typingFh{s\,A}{\lpApp{B}{A}}} \and
  \inferrule*{\typingFh{s}{A \to B} \\ \typingFh{t}{A}}{\typingFh{s\,t}{B}}\\
  \inferrule*{\lpPi x \istyFh{x} \lpImp \typingFh{\lpApp{s}{x}}{\lpApp{A}{x}}}{\typingFh{\TyLam{s}}{\All{A}}} \and
  \inferrule*{\istyFh{A} \\ \lpPi x \typingFh{x}{A} \lpImp \typingFh{\lpApp{s}{x}}{B}}{\typingFh{\Lam A s}{A \to B}}
\end{mathpar}

In Beluga, on the other hand, contexts are first class, and thus well-scopedness of expressions is inherent.
Hence \emph{the type formation judgement of the two-sorted system vanishes} completely, which reduces the definition of the typing judgement to:
\begin{mathpar}
  \mprset{andskip=1.5em,sep=2em}
  \inferrule*{\typingFh{s}{\All{B}}}{\typingFh{s\,A}{\lpApp{B}{A}}} \and
  \inferrule*{\typingFh{s}{A \to B} \\ \typingFh{t}{A}}{\typingFh{s\,t}{B}}\and
  \inferrule*{\lpPi x \typingFh{\lpApp{s}{x}}{\lpApp{A}{x}}}{\typingFh{\TyLam{s}}{\All{A}}} \and
  \inferrule*{\lpPi x \typingFh{x}{A} \lpImp \typingFh{\lpApp{s}{x}}{B}}{\typingFh{\Lam A s}{A \to B}}
\end{mathpar}

%%
%% Bibliography
%%

\bibliography{ref-short}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
