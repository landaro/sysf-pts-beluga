\documentclass[a4paper,UKenglish]{lipics-v2016}

\usepackage{microtype}%if unwanted, comment out or use option "draft"

% custom packages
\usepackage{mathpartir}
\usepackage{xspace}
\usepackage{etoolbox}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{float}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% For having two versions of a paper in one file.
% Stuff that does not fit into the short version can be encosed in \LONGVERSION{...}

\ifdefined\LONGVERSION
  \relax
\else
% short version:
 \newcommand{\LONGVERSION}[1]{}
 \newcommand{\SHORTVERSION}[1]{#1}
% % long version:
% \newcommand{\LONGVERSION}[1]{#1}
% \newcommand{\SHORTVERSION}[1]{}
%\newcommand{\SHORTVERSION}[1]{BEGIN~SHORT\ #1 \ END~SHORT}
\fi
\newcommand{\LONGSHORT}[2]{\LONGVERSION{#1}\SHORTVERSION{#2}}

\renewcommand{\TirNameStyle}[1]{\small \textsf{#1}}
\renewcommand{\RightTirNameStyle}[1]{\small \textsf{#1}}


\newcommand{\fromF}[1]{\lfloor #1 \rfloor}
\newcommand{\toF}[1]{\lceil #1 \rceil}
% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Relating System F and $\lambda$2: A Case Study in Coq, Abella and Beluga}
\titlerunning{Relating System F and $\lambda2$}

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Jonas Kaiser}
\author[2]{Brigitte Pientka}
\author[3]{Gert Smolka}
\affil[1]{Saarland University, Saarbrücken, Germany\\
  \texttt{jkaiser@ps.uni-saarland.de}}
\affil[2]{School of Computer Science, Montreal, Canada\\
  \texttt{bpientka@cs.mcgill.ca}}
\affil[3]{Saarland University, Saarbrücken, Germany\\
  \texttt{smolka@ps.uni-saarland.de}}
\authorrunning{J. Kaiser, B. Pientka and G. Smolka} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Jonas Kaiser, Brigitte Pientka and Gert Smolka}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{F.4.1 Mathematical Logic -- Lambda calculus and related systems}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation".
\keywords{Pure Type Systems, System F, de Bruijn Syntax, Higher-Order Abstract Syntax, Contextual Reasoning}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{2nd International Conference on Formal Structures for Computation and Deduction (FSCD 2017)}
\EventShortTitle{FSCD 2017}
\EventAcronym{FSCD}
\EventYear{2017}
\EventDate{September 3--9, 2017}
\EventLocation{Oxford, United Kingdom}
\EventLogo{}
\SeriesVolume{2}
\ArticleNo{XY}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% Content macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% uniform meta space
\newcommand{\ms}{\,}
\newcommand{\mrel}[1]{\mathrel{\ms #1 \ms}}

% Meta-Level Propositions
\newcommand{\Prop}{\ensuremath{\mathsf{PROP}}}
\newcommand{\Nat}{\mathbb{N}}

% Meta-level Symbols and Operators
\newcommand{\dom}[1]{\ensuremath{\textrm{dom($#1$)}}}
\newcommand{\OF}{\mrel{:}}
\newcommand{\mOr}{\mrel{\vee}}
\newcommand{\mAnd}{\mrel{\wedge}}
\newcommand{\mAll}[1]{\ensuremath{\forall} #1.\ms\ms}
\newcommand{\mEx}[1]{\ensuremath{\exists} #1.\ms\ms}
\newcommand{\mExu}[1]{\ensuremath{\exists!} #1.\ms\ms}
\newcommand{\bnfdef}{\mrel{::=}}
\newcommand{\eqdef}{\mrel{:=}}
\newcommand{\set}[1]{\ensuremath{\{#1\}}}

\newcommand{\SysL}{$\lambda$2\xspace}


% Syntactic sorts of the object languages
\newcommand{\TyF}{\ensuremath{\mathsf{Ty_{F}}}}
\newcommand{\TmF}{\ensuremath{\mathsf{Tm_{F}}}}
\newcommand{\TmL}{\ensuremath{\mathsf{Tm_{\lambda}}}}

\newcommand{\TyCtxF}{\ensuremath{\mathsf{C_{F}^{ty}}}}
\newcommand{\TmCtxF}{\ensuremath{\mathsf{C_{F}^{tm}}}}
\newcommand{\CtxL}{\ensuremath{\mathsf{C_{\lambda}}}}


% Generic type-system judgement predicates
\newcommand{\istyFpr}{\ensuremath{\mathsf{isty_{F}}}}
\newcommand{\typingFpr}{\ensuremath{\mathsf{ofty_{F}}}}
\newcommand{\typingLpr}{\ensuremath{\mathsf{ofty_{\lambda}}}}

% Judgements
\newcommand{\ty}{\mathsf{ty}}
\newcommand{\tm}{\mathsf{tm}}
\newcommand{\of}{\ensuremath{\!:\!}}
\newcommand{\cc}[2]{#1;#2} % compound System F contexts
\makeatletter
\newcommand{\raisemath}[1]{\mathpalette{\raisem@th{#1}}}
\newcommand{\raisem@th}[3]{\raisebox{#1}{\ensuremath{#2#3}}}
\makeatother
\newcommand{\tsAnnot}[2]{\vdash\hspace{-.7em}^{\raisemath{1.5pt}{\scriptscriptstyle{#2}}}_{\raisemath{0.3pt}{\scriptscriptstyle{#1}}}} % note: wrap instances in \mathbin
\newcommand{\cts}[2]{\ensuremath{(\,#1 #2 {})}} % context + turnstile for CMs
\newcommand{\tfF}{\tsAnnot{\mathsf{F}}{\ty}}  % for type formation judgement
\newcommand{\tyF}{\tsAnnot{\mathsf{F}}{\tm}}  % for typing judgement
\newcommand{\istyF}[2]{\ensuremath{{#1} \mathrel{\tfF} #2}}
\newcommand{\typingF}[3]{\ensuremath{{#1} \mathrel{\tyF} #2 \OF #3}}
\newcommand{\tyL}{\tsAnnot{\lambda}{}} % for typing judgement
\newcommand{\typingL}[3]{\ensuremath{{#1} \mathrel{\tyL} #2 \OF #3}}
\newcommand{\inL}{\mrel{\in_{\lambda}}}
\newcommand{\tfP}{\tsAnnot{\mathsf{P}}{\ty}}  % for type formation judgement
\newcommand{\istyFh}[1]{\ensuremath{#1\ms\mathsf{ty}}}
\newcommand{\typingFh}[2]{\ensuremath{#1 \mathbin{:_{F}} #2}}
\newcommand{\sortLh}[1]{\ensuremath{\mathcal{S}\ms#1}}
\newcommand{\typingLh}[2]{\ensuremath{#1 \mathbin{:_{\lambda}} #2}}


% The type and term relations
\newcommand{\tyr}{\mathrel{\sim}}
\newcommand{\tmr}{\mathrel{\approx}}

\newcommand{\Rext}[1]{\ensuremath{#1^{\mathsf{ext}}}}
\newcommand{\Rshift}[1]{\ensuremath{#1^{\Uparrow}}}

% relational context morphisms
\newcommand{\tyctxrelFL}[3]{\ensuremath{#1\mathrel{\mathop{\longrightarrow}^{#2}\limits}#3}}
\newcommand{\tyctxrelLF}[3]{\ensuremath{#1\mathrel{\mathop{\longleftarrow}^{#2}\limits}#3}}
\newcommand{\tmctxrelFL}[4]{\ensuremath{#1\mathrel{\mathop{\longrightarrow}^{#2}_{#3}\limits}#4}}
\newcommand{\tmctxrelLF}[4]{\ensuremath{#1\mathrel{\mathop{\longleftarrow}^{#2}_{#3}\limits}#4}}

% L-Prolog syntax
\newcommand{\lpPi}[1]{\mathbf{\Pi} #1.\ms\ms}
\newcommand{\lpApp}[2]{#1\langle#2\rangle}
\newcommand{\lpImp}{\mrel{=\!\blacktriangleright}}

% Object Syntax
\newcommand{\Prp}{\ensuremath{\textrm{\textasteriskcentered}}}
\newcommand{\Typ}{\ensuremath{\square}}
\newcommand{\All}{\ensuremath{\forall.\,}}
\newcommand{\nAll}[1]{\ensuremath{\forall #1.\,}}
\newcommand{\Lam}[1]{\ensuremath{\lambda #1.\,}}
\newcommand{\TyLam}{\ensuremath{\Lambda.\,}}
\newcommand{\nTyLam}[1]{\ensuremath{\Lambda #1.\,}}
\newcommand{\Prod}[1]{\ensuremath{\Pi #1.\,}}

\newcommand{\emptyctx}{\ensuremath{\bullet}}

% Substitutions
\newcommand{\subst}[1]{\hphantom{|}\!\![{#1}]}
\newcommand{\scons}{\mathbin{\hspace{0.05em}\cdot\hspace{0.05em}}}
\newcommand{\scomp}{\mathbin{\hspace{-0.1em}{\circ}\hspace{-0.1em}}}
\newcommand{\hscomp}{\mathbin{\hspace{-0.1em}{\hat\circ}\hspace{-0.1em}}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\up}{{\Uparrow}}
%\newcommand{\shift}{\ensuremath{\hspace{0.06em}\textsf{\small +}\!1\hspace{-0.06em}}}
%\newcommand{\ushift}{\ensuremath{\textsf{\small -}\!1}}
\newcommand{\shift}{\ensuremath{\hspace{0.1em}\mathsf{+}\hspace{0.08em}\!1}}
\newcommand{\ushift}{\ensuremath{\hspace{0.1em}\textsf{--}\hspace{0.1em}\!1}}

% Facts without proof
\theoremstyle{plain}
\newtheorem{fact}[theorem]{Fact}
%\AtEndEnvironment{fact}{\null\hfill\qedsymbol}%

%%% Content macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
  We give three formalisations of a proof of the equivalence of the usual, two-sorted presentation of System~F and its single-sorted pure type system (PTS) variant \SysL.
  This is established by reducing the typability problem of F to \SysL and vice versa.
  A key challenge is the treatment of variable binding and contextual information.
  The formalisations all share the same high level proof structure using relations to connect the type systems.
  They do, however, differ significantly in their representation and manipulation of variables and contextual information.
  In Coq, we use pure de~Bruijn indices and parallel substitutions.
  In Abella, we use higher-order abstract syntax (HOAS) and nominal constants of the ambient reasoning logic.
  In Beluga, we also use HOAS but within contextual modal type theory.
  Our contribution is twofold.
  First, we present and compare a collection of machine-checked solutions to a non-trivial theoretical result.
  Second, we propose our proof as a benchmark, complementing the POPLmark challenge by testing how well a given proof assistant or framework handles complex contextual information involving multiple type systems.
\end{abstract}

\section{Introduction}
\label{sec:intro}

\begin{figure}[t]
  \begin{center}
    \begin{align*}
      &\TyF & A, B &\bnfdef X \mid A \to B \mid \nAll X A & \quad\qquad&\TmF & s, t &\bnfdef x \mid s\,t \mid \Lam {x \of A} s \mid s\,A \mid \nTyLam X s\\
      &\TyCtxF & \Delta &\bnfdef \emptyset \mid \Delta, X & \quad\qquad&\TmCtxF & \Gamma &\bnfdef \emptyctx \mid \Gamma, x \of A
    \end{align*}
    \begin{mathpar}
      \inferrule*{X \in \Delta}{\istyF{\Delta}{X}} \and
      \inferrule*{\istyF{\Delta}{A} \\ \istyF{\Delta}{B}}{\istyF{\Delta}{A \to B}} \and
      \inferrule*[right=$X \notin \Delta$]{\istyF{\Delta,X}{A}}{\istyF{\Delta}{\nAll X A}} \and
      \inferrule*{\Gamma(x)=A \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{x}{A}} \\
      \inferrule*{\typingF{\cc{\Delta}{\Gamma}}{s}{A \to B} \\ \typingF{\cc{\Delta}{\Gamma}}{t}{A}}{\typingF{\cc{\Delta}{\Gamma}}{s\,t}{B}} \and
      \inferrule*[right=$x \notin \dom{\Gamma}$]{\typingF{\cc{\Delta}{\Gamma,x \of A}}{s}{B} \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{\Lam {x \of A} s}{A \to B}} \\
      \inferrule*{\typingF{\cc{\Delta}{\Gamma}}{s}{\nAll X B} \\ \istyF{\Delta}{A}}{\typingF{\cc{\Delta}{\Gamma}}{s\, A}{B\subst{A/X}}} \and
      \inferrule*[right=$X \notin \Delta$]{\typingF{\cc{\Delta, X}{\Gamma}}{s}{A}}{\typingF{\cc{\Delta}{\Gamma}}{\nTyLam X s}{\nAll X A}}
    \end{mathpar}
  \end{center}
  \caption{Stratified System~F: types, terms, contexts, type formation and typing.}
  \label{fig:sys-f}
\end{figure}

\begin{figure}[t]
  \begin{center}
    \begin{align*}
      &\TmL & a, b, c, d &\bnfdef \Prp \mid \Typ \mid x \mid a\,b \mid \Lam{x \of a} b \mid \Prod{x \of a} b & \qquad\qquad&\CtxL & \Psi &\bnfdef \emptyctx \mid \Psi, x \of a
    \end{align*}
    \begin{mathpar}
      \mprset{sep=1.5em}
      \inferrule*{~}{\typingL{\Psi}{\Prp}{\Typ}} \and
      \inferrule*{x \of a \in \Psi \\ \typingL{\Psi}{a}{s}}{\typingL{\Psi}{x}{a}} \and
      \inferrule*[right=$x \notin \dom{\Psi}$]{\typingL{\Psi}{a}{s} \\ \typingL{\Psi,x \of a}{b}{\Prp}}{\typingL{\Psi}{\Prod{x \of a} b}{\Prp}} \\
      \inferrule*{\typingL{\Psi}{a}{\Prod{x \of c} d} \\ \typingL{\Psi}{b}{c}}{\typingL{\Psi}{a\, b}{d\subst{b/x}}} \and
      \inferrule*[right=$x \notin \dom{\Psi}$]{\typingL{\Psi}{a}{s} \\ \typingL{\Psi, x \of a}{b}{c} \\ \typingL{\Psi, x \of a}{c}{\Prp}}{\typingL{\Psi}{\Lam{x \of a} b}{\Prod{x \of a} c}}
    \end{mathpar}
  \end{center}
  \caption{PTS: terms, contexts, and the uniform type system \SysL; $s$ ranges over the sorts $\Prp$ and $\Typ$.}
  \label{fig:sys-l}
\end{figure}

There are different presentations of ``System~F'' in the literature and they are effectively considered equivalent, which is used to justify the transport of theoretical results between said presentations.
The assumed notion of equivalence is primarily a reduction of the typability problem from one system to the other.
While the existence of a suitable correspondence between the systems may appear likely or obvious, it turns out that actually proving it formally is surprisingly intricate.
As long as the systems in question use the same expression syntax, the proofs are usually tedious but straightforward.
If, on the other hand, not only the type systems, but also the syntactic languages differ, then establishing the correct correspondence becomes much more involved.
The goal of this paper is to showcase various formalisation techniques to deal with intricacies that arise in such an equivalence proof.

System~F in its original form is due to Girard~\cite{Girard1972, Girard1989}, who introduced it in the context of proof theory.
It was also independently discovered by Reynolds~\cite{DBLP:conf/programm/Reynolds74} as the polymorphic $\lambda$-calculus.
For the purposes of this paper we consider two presentations that differ sufficiently to demonstrate the various complications.
The first, called F and shown in Figure~\ref{fig:sys-f}, is the common two-sorted, or stratified, presentation, as for example given by Harper~\cite{Harper2013}.
The second, given in Figure~\ref{fig:sys-l}, is the pure type system (PTS) \SysL, which appears as a corner in Barendregt's $\lambda$-cube~\cite{DBLP:journals/jfp/Barendregt91}.

In~\cite{Geuvers1993}, Geuvers gives a proof sketch that valid typing judgements can be translated between these two presentations.
In~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq} we then gave the first proof, machine-checked in Coq, of the full reduction result.
There we use translation functions, written as $\fromF{~}$ and $\toF{~}$ respectively, to map the terms and types of one system into the respective other.
They are defined recursively over the respective syntactic languages.
We then proceed to show that these translations correctly transport typability in both directions to obtain the following reduction theorem:
\begin{align*}
  \typingF{}{s}{A} &\iff \typingL{}{\fromF s}{\fromF A} \mAnd \typingL{}{\fromF  A}{\Prp}\\
  \typingL{}{a}{b} \mAnd \typingL{}{b}{\Prp} &\iff \typingF{}{\toF a}{\toF b}
\end{align*}

For the proof we developed the versatile notion of generalised context morphism lemmas (CML) to reason about various properties of the translations.
This allowed us to cope with the fact that the translations had to be defined on the untyped syntax and eventually prove certain cancellation laws.
However, working with the untyped syntax felt wrong in the sense that only well-formed types and well-typed terms carry actual meaning.
We remedy this dissonance here by instead using relations to precisely construct the often informally assumed correspondence of the two systems.
These relations are formally realised as inductive predicates.
Their definitions are given in Figure~\ref{fig:rel}.

\begin{figure}[t]
  \begin{center}
    \begin{align*}
      \Theta &\bnfdef \emptyctx \mid \Theta, (X,y) & \Sigma &\bnfdef \emptyctx \mid \Sigma, (x,y)
    \end{align*}
    \begin{mathpar}
      \inferrule*{(X,y) \in \Theta}{\Theta \vdash X \tyr y} \and
      \inferrule*[right=$x \notin \Theta$]{\Theta \vdash A \tyr a \\ \Theta \vdash B \tyr b}{\Theta \vdash A \to B \tyr \Prod{y \of a} b} \and
      \inferrule*[right={$X,y \notin \Theta$}]{\Theta, (X,y) \vdash A \tyr a}{\Theta \vdash \nAll{X} A \tyr \Prod{y \of \Prp} a}\\
      \inferrule*{(x,y) \in \Sigma}{\cc{\Theta}{\Sigma} \vdash x \tmr y} \and
      \inferrule*{\cc{\Theta}{\Sigma} \vdash s \tmr a \\ \cc{\Theta}{\Sigma} \vdash t \tmr b}{\cc{\Theta}{\Sigma} \vdash s\,t \tmr a\,b} \and
      \inferrule*{\cc{\Theta}{\Sigma} \vdash s \tmr a \\ \Theta \vdash A \tyr b}{\cc{\Theta}{\Sigma} \vdash s\,A \tmr a\,b}\\
      \inferrule*[right={$x,y \notin \Theta,\Sigma$}]{\Theta \vdash A \tyr a \\ \cc{\Theta}{\Sigma, (x,y)} \vdash s \tmr b}{\cc{\Theta}{\Sigma} \vdash \Lam{x \of A} s \tmr \Lam{y \of a} b} \and
      \inferrule*[right={$X,y \notin \Theta,\Sigma$}]{\cc{\Theta, (X,y)}{\Sigma} \vdash s \tmr a}{\cc{\Theta}{\Sigma} \vdash \nTyLam{X} s \tmr \Lam{y \of \Prp} a}
    \end{mathpar}
  \end{center}
  \caption{Inductive characterisation of $\tyr$ and $\tmr$; $\Theta$ and $\Sigma$ track related type and terms variables.}
  \label{fig:rel}
\end{figure}

While the use of these relations allows us to focus on the well-typed parts of the two systems and hence bypass several of the complications outlined in~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}, we still have to face the metaphorical elephant in the room, namely variable binding and context manipulation.
More precisely, we have to represent and handle contexts that track various kinds of information, like the set of defined variables, their associated types, their correspondence to other variables, relational assumptions on types of said variables, and so on.
To make the situation fully explicit: our contexts are linearisations of directed acyclic graphs of dependent records.

In the following we present three formalisations that each deal with the complexities of contextual information and variable binding in different ways.

The first (Section~\ref{sec:coq}) is a pure de Bruijn setup with parallel substitutions.
This is done in Coq with major support from the Autosubst framework~\cite{DBLP:conf/itp/SchaferTS15}.
The development reveals yet another occurrence of CMLs, this time generalised from renamings to variable relations.
The tracking of context information has to be implemented and managed explicitly.

The second formalisation (Section~\ref{sec:abella}) is done in Abella, using higher-order abstract syntax (HOAS)\cite{AbellaTutorial}.
The HOAS approach delegates the binding mechanisms of the object languages to those of the meta theory.
In Abella, this happens to be a first order logic with nominal constants, which are used to represent object variables.
Contextual information is handled implicitly at the object level and appears as an unstructured list of judgements at the meta level.
Considerable work then goes into reifying the aforementioned dependency structure of the context.

The third proof (Section~\ref{sec:beluga}) is done in Beluga, also following the HOAS design \cite{Pientka:CADE15}.
Here the meta theory is contextual modal type theory, which, as the name suggests, is very good at expressing and manipulating fairly complex context structures.
In contrast to the other two results, the Beluga proofs have to be given as explicit proof terms, some of which are of considerable size.
Fortunately, Beluga's strong support for manipulating contextual information allows us to get away with the smallest amount of language-local meta theory, which ameliorates this somewhat.

All three proofs follow the same basic structure, which we briefly outline in Section~\ref{sec:equi}.
This allows us to concentrate on, and better compare, the various ways in which the low-level technicalities are handled.

Our contributions:
\begin{itemize}
\item We present and compare three rather different machine checked formalisations of the technically intricate reduction of typability from System~F to the PTS \SysL and vice versa.
\item We propose that our equivalence proof serves as a benchmark for reasoning about and relating multiple type systems and languages that involve variable binding.
  The key aspect of this benchmark is the representation and manipulation of contexts that track multiple kinds of information and exhibit complex dependency structures.
  As such it can be seen as a complement to the benchmarks proposed by Felty, Momigliano and Pientka in \cite{Felty:ITP10,Felty:orbi-survey} which described various small crafted examples to highlight context reasoning and the POPLmark challenge~\cite{poplmark} which tests a frameworks ability to develop the theory of a single object language and type system.
\end{itemize}

\section{Equivalence}
\label{sec:equi}

The core challenge of the proof is the fact that F clearly distinguishes types and terms with separate syntactic sorts, $\TyF$ and $\TmF$ respectively, while \SysL merges these into a single syntactic sort $\TmL$.
The distinction still exists in \SysL but it is semantically imposed through the type system, rather than at the level of syntax.
Further consequences are the existence of two variable scopes in F, with separate abstraction and application mechanisms, while the same concepts are uniformly represented in \SysL for a single variable scope.
This extends to the formation of (dependent) function spaces as well.
In essence the two systems differ in how explicit and readily available certain structural properties are.

As usual, removing structure is easier than recovering it, and this will become apparent in the following, where some of the required lemmas require noticeably more work than their seemingly symmetrical counterparts.

The basic idea of the proof is to construct two relations $\tyr$ and $\tmr$ that put the types and respectively the terms of the two languages in correspondence (see Figure ~\ref{fig:rel}).
% On one side the distinction is of course only semantic, as both live in the syntactic sort $\TmL$.
% A concrete construction of such relations is given in Figure~\ref{fig:rel}.
%
To obtain the desired equivalence results we then have to demonstrate that our relations exhibit the following properties:
\begin{enumerate}
  \item $\tyr$ is functional and injective.
  \item $\tyr$ is left-total and type-formation preserving on the well-formed types of F.
  \item $\tyr$ is right-total and type-formation preserving on the propositions of \SysL.
  \item $\tmr$ is functional and injective.
  \item $\tmr$ is left-total and typing preserving on the well-typed terms of F.
  \item $\tmr$ is right-total and typing preserving on the proofs of \SysL.
\end{enumerate}
Note that a proposition of \SysL is any term $a \OF \TmL$ such that $\typingL{}{a}{\Prp}$ holds.
A proof of \SysL is any term $b \OF \TmL$ such that $\typingL{}{b}{a}$ holds for $a$ a proposition of \SysL.
We can now formulate, and easily prove, the following equivalences:

\begin{theorem}[Reductions from F to \SysL]
  \begin{align*}
    \istyF{}{A} &\iff \mExu{a} {} \vdash A \tyr a \mAnd \typingL{}{a}{\Prp}\\
    \typingF{}{s}{A} &\iff \mExu{b a} {} \vdash s \tmr b \mAnd {} \vdash A \tyr a \mAnd \typingL{}{b}{a} \mAnd \typingL{}{a}{\Prp}
  \end{align*}
\end{theorem}

\begin{proof}
  The forward directions are simply the corresponding left-to-right preservation and left-totality results of $\tmr$ and $\tyr$.
  Uniqueness follows from functionality.
  For the inverse direction we use preservation (here from right to left) and uniqueness.
\end{proof}

\begin{theorem}[Reductions from \SysL to F]
  \begin{align*}
    \typingL{}{a}{\Prp} &\iff \mExu{A} {} \vdash A \tyr a \mAnd \istyF{}{A}\\
    \typingL{}{b}{a} \mAnd \typingL{}{a}{\Prp} &\iff \mExu{s A} {} \vdash s \tmr b \mAnd {} \vdash A \tyr a \mAnd \typingF{}{s}{A}
  \end{align*}
\end{theorem}

\begin{proof}
  Dual to the previous result.
\end{proof}

For the remainder of the paper, we focus on how F, \SysL and the two relations $\tyr$ and $\tmr$ are represented in three proof assistants, and how the various properties of the relations are obtained.

\section{Coq}
\label{sec:coq}

\begin{figure}
  \begin{center}
    \begin{align*}
      A, B &\bnfdef x_\ty \mid A \to B \mid \All A & s, t &\bnfdef x_\tm \mid s\,t \mid \Lam A s \mid s\,A \mid \TyLam s & &x, N \OF \Nat
    \end{align*}
    \begin{mathpar}
      \inferrule*{x < N}{\istyF{N}{x_\ty}} \and
      \inferrule*{\istyF{N}{A} \\ \istyF{N}{B}}{\istyF{N}{A \to B}} \and
      \inferrule*{\istyF{N+1}{A}}{\istyF{N}{\All A}} \and
      \inferrule*{A_x = A \\ \istyF{N}{A}}{\typingF{\cc{N}{A_n,\ldots, A_0}}{x_\tm}{A}} \\
      \inferrule*{\typingF{\cc{N}{\Gamma}}{s}{A \to B} \\ \typingF{\cc{N}{\Gamma}}{t}{A}}{\typingF{\cc{N}{\Gamma}}{s\,t}{B}} \and
      \inferrule*{\typingF{\cc{N}{\Gamma,A}}{s}{B} \\ \istyF{N}{A}}{\typingF{\cc{N}{\Gamma}}{\Lam A s}{A \to B}} \\
      \inferrule*{\typingF{\cc{N}{\Gamma}}{s}{\All A} \\\istyF{N}{B}}{\typingF{\cc{N}{\Gamma}}{s\, B}{A\subst{B\scons\id}}} \and
      \inferrule*{\typingF{\cc{N+1}{\Gamma\subst{\shift}}}{s}{A}}{\typingF{\cc{N}{\Gamma}}{\TyLam s}{\All A}}
    \end{mathpar}
  \end{center}
  \caption{System~F -- de Bruijn encoding in Coq; term variable contexts $\Gamma$ are lists of types.}
  \label{fig:sys-f-coq}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{align*}
      a, b, c, d &\bnfdef \Prp \mid \Typ \mid x \mid a\,b \mid \Lam a b \mid \Prod a b & &x \OF \Nat
    \end{align*}
    \begin{mathpar}
      \mprset{sep=1.5em}
      \inferrule*{~}{0 \of a\subst{\shift} \inL \Psi,a}\and
      \inferrule*{x \of a \inL \Psi}{(x+1) \of a\subst{\shift} \inL \Psi,b}\and
      \inferrule*{~}{\typingL{\Psi}{\Prp}{\Typ}} \and
      \inferrule*{x \of a \inL \Psi \\ \typingL{\Psi}{a}{s}}{\typingL{\Psi}{x}{a}} \\
      \inferrule*{\typingL{\Psi}{a}{s} \\ \typingL{\Psi,a}{b}{\Prp}}{\typingL{\Psi}{\Prod a b}{\Prp}} \and
      \inferrule*{\typingL{\Psi}{a}{\Prod c d} \\ \typingL{\Psi}{b}{c}}{\typingL{\Psi}{a\, b}{d\subst{b\scons\id}}} \and
      \inferrule*{\typingL{\Psi}{a}{s} \\\\ \typingL{\Psi, a}{b}{c} \\ \typingL{\Psi, a}{c}{\Prp}}{\typingL{\Psi}{\Lam a b}{\Prod a c}}
    \end{mathpar}
  \end{center}
  \caption{\SysL{} -- de Bruijn encoding in Coq; dependent contexts $\Psi$ are lists of terms.}
  \label{fig:sys-l-coq}
\end{figure}

For the Coq proof we reuse the pure de Bruijn encoding of the two systems and the corresponding language local meta theory developed in~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq} with major support from the Autosubst framework~\cite{DBLP:conf/itp/SchaferTS15}.
The de Bruijn language definitions are given in Figures~\ref{fig:sys-f-coq}~and~\ref{fig:sys-l-coq}.
The main feature of de Bruijn syntax is the absence of variable names.
Variables are instead represented as numerical indices, where $n$ references the $n$th enclosing binder of the correct scope.
Dangling references represent free variables that instead reference positions in an enclosing context, indexed from right to left.
Note that we keep the dot around as a notational device to uniformly indicate the presence of a binding constructor, even if nothing remains to the left of it (e.g.\ $\TyLam s$), as it marks the precise spot where substitutions and indices have to be adjusted.
The application of a parallel substitution $\sigma$ to a term $s$ is written $s\subst{\sigma}$ where $\sigma$ is a function from $\Nat$ that acts on all free variables of $s$ at once.
The Autosubst framework provides a normalisation procedure for such terms with applied substitutions.
The existence of computable normal forms was demonstrated in~\cite{SchaeferEtAl:2009:Completeness}.
In the following we will only focus on those aspects that have an immediate impact on our present proof.
For an in-depth discussion of the interaction of pure de Bruijn syntax, parallel substitutions and context morphism lemmas we refer to~\cite{deBruijn1972, SchaeferEtAl:2009:Completeness, DBLP:conf/itp/SchaferTS15, abadi1991, GoguenMcKinna1997, KaiserEtAl:2017:sysf_pts_equiv_coq}.

In the definition of F in Figure~\ref{fig:sys-f-coq}, observe how the type variable context $\Delta$ degenerates to a plain natural number $N$.
It is taken as an exclusive upper bound to the admissible type variable indices, hence $N = 0$ represents the empty context.
The term variable context $\Gamma$ is simply a list of types, since free variables are coded as context positions.
The $\beta$-substitution $B\scons{\id}$ used in the type specialisation rule maps the free index 0 to $B$ and lowers all other indices by 1.

We further observe that for \SysL, defined in Figure~\ref{fig:sys-l-coq}, context lookup is characterised inductively: $x \of a \inL \Psi$.
The need for this arises from the fact that the PTS contexts are dependent and the more general issue that in a de Bruijn setting, terms are not stable under context modifications.
Hence, upon extraction of $a$ from a context $\Gamma$, all free variables of $a$ have to be adjusted by an amount that depends on the position of $a$ in $\Gamma$.
The given inductive characterisation elegantly handles this complication.

Now that we have a good understanding of how our systems operate concretely, let us consider how we relate them.
Similar to the way typing contexts are explicitly represented as lists of terms or types, we are going to track explicitly which variables are related in our definition of our relations $\tyr^R$ and $\tmr^R_S$, where the relational parameters $R$ and $S$ correspond to the contexts $\Theta$ and $\Sigma$ from Figure~\ref{fig:rel}:
\begin{mathpar}
  \inferrule*{x\,R\,y}{x_\ty\,\tyr^R\,y} \and
  \inferrule*{A\,\tyr^R\,a \\ B\,\tyr^{\Rshift{R}}\,b}{A \to B\,\tyr^R\,\Prod a b} \and
  \inferrule*{A\,\tyr^{\Rext{R}}\,a}{\All A\,\tyr^R\,\Prod \Prp a}\\
  \inferrule*{x\,S\,y}{x_\tm\,\tmr^R_S\,y} \and
  \inferrule*{s\,\tmr^R_S\,a \\ t\,\tmr^R_S\,b}{s\,t\,\tmr^R_S\,a\,b} \and
  \inferrule*{s\,\tmr^R_S\,a \\ A\,\tyr^R\,b}{s\,A\,\tmr^R_S\,a\,b}\\
  \inferrule*{A\,\tyr^R\,a \\ s\,\tmr^{\Rshift{R}}_{\Rext{S}}\,b}{\Lam A s\,\tmr^R_S\,\Lam a b} \and
  \inferrule*{s\,\tmr^{\Rext{R}}_{\Rshift{S}}\,a}{\TyLam s\,\tmr^R_S\,\Lam \Prp a}
\end{mathpar}
It should be clear that $R$ and $S$ track pairs of indices of type, and respectively, term variables.
We technically represent them as lists of type $\mathsf{list}\,(\mathsf{var} \times \mathsf{var})$ and use $x\,R\,y$ to denote that the pair $(x,y)$ is in $R$.
The interesting part of this definition is how these auxiliary parameters have to be modified when binders are traversed, which we denoted above by $\Rshift{R}$ and $\Rext{R}$.
In order to precisely define these operations, let us recall the required action on a parallel substitution $\sigma$ that is pushed underneath a binder:
\begin{align*}
  (\All A)\subst{\sigma} \qquad\longmapsto\qquad \All A\subst{0 \scons \sigma \scomp \shift}
\end{align*}
The $\subst{0 \scons \_}$ part ensures that any variable referencing the presently traversed binder is preserved as such.
Meanwhile the $\subst{\_ \scons \sigma \scomp \shift}$ part ensures that every index $n + 1$ is mapped to $\sigma(n)\subst{\shift}$, where the $\shift$ ensures that no free variable in the range of $\sigma$ are accidentally captured.

For our present proof we are now traversing binders \emph{almost} in lockstep.
For the simple cases where we have a binder on both sides of the relation, and moreover, the bound variables actually correspond according to the information tracked in $R$, we define, analogously to the binder traversal for substitutions:
\begin{align*}
  \Rext{R} \eqdef (0,0) \mathop{::} \mathsf{bimap}\,(\shift)\,(\shift)\,R
\end{align*}
where $\mathsf{bimap}\,f\,g\,R$ simply applies $f$ to all left projections of $R$ and $g$ to all right projections.

The other possible scenario has a binder on the \SysL side that has no counterpart in F with respect to the contextual information in $R$, like the \emph{not-really dependent} PTS product that corresponds to an arrow type in F.
As a consequence of this spurious binding, the \SysL indices in $R$ have to be shifted relative to their F counterparts.
This one-sided index adjustment is obtained with
\begin{align*}
  \Rshift{R} \eqdef \mathsf{bimap}\,\id\,(\shift)\,R
\end{align*}

\begin{fact}
  \label{fac:rel-ext}
  Both $\Rext{R}$ and $\Rshift{R}$ preserve injectivity and functionality of $R$.\hfill\qedsymbol
\end{fact}

\begin{lemma}
  \label{lem:tyr-inj-fun}
  The type relation $\tyr^R$ is injective/functional, whenever $R$ is injective/functional.
\end{lemma}
\begin{proof}
  Straightforward inductions using Fact~\ref{fac:rel-ext}.
\end{proof}

To obtain the same result for $\tmr^R_S$ we additionally rely on $R$ and $S$ having disjoint ranges, that is, no PTS variable is considered related to both a type and a term variable.
We denote this by $R \| S$ and observe
\begin{fact}
  \label{fac:rel-disjoint}
  The property $R \| S$ is preserved under extending one relation and shifting the other, that is w.l.o.g.: $R \| S \implies \Rshift{R} \| \Rext{S}$.\hfill\qedsymbol
\end{fact}
\begin{lemma}
  \label{lem:rel-disjoint}
  Disjointedness of ranges lifts from variable relations $R$ and $S$ to $\tyr^R$ and $\tmr^R_S$:
  \begin{align*}
    R \| S \implies A \tyr^R a \implies s \tmr^R_S a \implies \bot
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $A \tyr^R a$ and discriminating on $s \tmr^R_S a$, using Fact~\ref{fac:rel-disjoint}.
\end{proof}
\begin{lemma}
  \label{lem:tmr-inj-fun}
  The term relation $\tmr^R_S$ is functional, whenever $R$ and $S$ are functional.
  It is injective, whenever $R$ and $S$ are injective and $R \| S$ holds.
\end{lemma}
\begin{proof}
  Straightforward inductions.
  Injectivity relies on the premise $R \| S$ and Lemma~\ref{lem:rel-disjoint} to discharge non-matching applications.
  Subderivations for $\tyr^R$ are handled with Lemma~\ref{lem:tyr-inj-fun}.
\end{proof}

Proving the left and right totality and preservation results is slightly more interesting, as we have to generalise to open judgements and non-empty contexts.
We achieve this with suitable proof invariants that are adapted from the notion of \emph{generalised context morphism} laid out in~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}.
The key difference is that instead of a renaming $\xi$ that maps from one context to another, we here consider a relation on variables that places two contexts in correspondence.
All invariants are set up such that they vacuously hold when the initial context happens to be empty.
We start with type formation and the direction from left (F) to right (\SysL):
\begin{align*}
  \tyctxrelFL{N}{R}{\Psi} \eqdef \mAll {x < N} \mEx y x\,R\,y \mAnd y \of \Prp \inL \Psi
\end{align*}
\begin{fact}
  \label{fac:inv-tyfl-ext}
  The invariant $\tyctxrelFL{N}{R}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tyctxrelFL{N}{R}{\Psi} \implies \tyctxrelFL{N}{\Rshift{R}}{\Psi,a} & &\tyctxrelFL{N}{R}{\Psi} \implies \tyctxrelFL{N+1}{\Rext{R}}{\Psi,\Prp} \tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  \label{lem:tyr_fl_tot_pres}
  The type-relation $\tyr^R$ is total from left to right and preserves type formation:
  \begin{align*}
    \istyF{N}{A} \implies \mAll {R\,\Psi} \tyctxrelFL{N}{R}{\Psi} \implies \mEx a A\,\tyr^R\,a \mAnd \typingL{\Psi}{a}{\Prp}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\istyF{N}{A}$. The two binder cases use Fact~\ref{fac:inv-tyfl-ext}.
\end{proof}

For the inverse direction we establish preservation of type formation and right totality along the following invariant:
\begin{align*}
  \tyctxrelLF{N}{R}{\Psi} \eqdef \mAll {y} y\of\Prp \inL \Psi \implies \mEx x x\,R\,y \mAnd x < N
\end{align*}
\begin{fact}
  \label{fac:inv-tylf-ext}
  The invariant $\tyctxrelLF{N}{R}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tyctxrelLF{N}{R}{\Psi} \implies \typingL{\Psi}{a}{\Prp} \implies \tyctxrelLF{N}{\Rshift{R}}{\Psi,a} & &\tyctxrelLF{N}{R}{\Psi} \implies \tyctxrelLF{N+1}{\Rext{R}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  \label{lem:tyr_lf_tot_pres}
  The type-relation $\tyr^R$ is total from right to left and preserves type formation:
  \begin{align*}
    \typingL{\Gamma}{a}{\Prp} \implies \mAll {R\,N} \tyctxrelLF{N}{R}{\Gamma} \implies \mEx A A\,\tyr^R\,a \mAnd \istyF{N}{A}
  \end{align*}
\end{lemma}
\begin{proof}
  Induction on $\typingL{\Gamma}{a}{\Prp}$, using Fact~\ref{fac:inv-tylf-ext}.
  One complication is the disambiguation of a given PTS-product $\Prod{a} b$, where $a$ is known to live in some sort $s$.
  Discriminating on $s$ allows us to correctly choose either an arrow type $A \to B$, or a universal quantification $\All B$.
  Further requirements are the degeneracy of the sort $\Typ$, as well as propagation and substitutivity for $\tyL$.
\end{proof}

When it comes to the preservation and totality results for $\tmr^R_S$, the overhead for explicitly tracking of contextual information becomes most apparent.
Since some of the typing rules for applications ascribe types that a constructed from a non-trivial substitution operation, we require substitutivity results for the judgements under consideration.
For $\tyr^R$, in particular we require $\beta$-substitutivity:
\begin{fact}
  The type relation $\tyr^R$ is closed under $\beta$-substitutions:
  \begin{align*}
    B\,\tyr^R\,b \implies A\,\tyr^{\Rext{R}}\,a \implies A\subst{B\scons\id}\,\tyr^R\,a\subst{b\scons\id} \tag*{\qedsymbol}
  \end{align*}
\end{fact}
The proof of this fact is a lengthy but fairly straightforward construction that first generalises the two concrete $\beta$-substitutions to arbitrary parallel substitutions $\sigma$ and $\tau$.
The result is still not provable directly, as closure of $\tyr^R$ under weakening is needed.
This in turn is generalised to a statement for arbitrary renamings $\xi$ and $\zeta$ in place of $\sigma$ and $\tau$.
In essence we again follow the CML proof pattern described in~\cite{KaiserEtAl:2017:sysf_pts_equiv_coq}.

We can finally tackle the technically most intricate part of the proof.
The invariant for preservation of typing from F to \SysL is
\begin{align*}
  \tmctxrelFL{\Gamma}{R}{S}{\Psi} \eqdef \mAll {x \of A \in \Gamma} \mEx{y\,a} A\,\tyr^R\,a \mAnd x\,S\,y \mAnd y \of a \inL \Psi
\end{align*}
\begin{fact}
  \label{fac:inv-tmfl-ext}
  The invariant $\tmctxrelFL{\Gamma}{R}{S}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
  &\tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies A\,\tyr^R\,a \implies \tmctxrelFL{\Gamma,A}{\Rshift{R}}{\Rext{S}}{\Psi,a} & &\tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies \tmctxrelFL{\Gamma\subst{\shift}}{\Rext{R}}{\Rshift{S}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  The term relation $\tmr^R_S$ is total from left to right and preserves typing.
  \begin{align*}
    \typingF{\cc{N}{\Gamma}}{s}{A} \implies &\mAll{R\,S\,\Psi} R\ms\ms\mathsf{func} \implies \tyctxrelFL{N}{R}{\Psi} \implies \tmctxrelFL{\Gamma}{R}{S}{\Psi} \implies \\
                                            &\mEx{a\,b} A\,\tyr^R\,b \mAnd s\,\tmr^R_S\,a \mAnd \typingL{\Psi}{a}{b} \mAnd \typingL{\Psi}{b}{\Prp}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\typingF{\cc{N}{\Gamma}}{s}{A}$.
  Both the invariant $\tmctxrelFL{\Gamma}{R}{S}{\Psi}$, as well as Lemma~\ref{lem:tyr_fl_tot_pres}, are used to obtain related types in the variable case.
  Functionality of $R$ allows us to equate these.
\end{proof}

The final piece is the preservation of typing from \SysL to F.
Here we use:
\begin{align*}
  \tmctxrelLF{\Gamma}{R}{S}{\Psi} \eqdef \mAll{y\,a} y \of a \inL \Psi \implies \typingL{\Psi}{a}{\Prp} \implies \mEx{x\,A} A\,\tyr^R\,a \mAnd x\,S\,y \mAnd x \of A \in \Gamma
\end{align*}
\begin{fact}
  \label{fac:inv-tmfl-ext}
  The invariant $\tmctxrelLF{\Gamma}{R}{S}{\Psi}$ is preserved under corresponding extensions:
  \begin{align*}
    &\tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies A\,\tyr^R\,a \implies \tmctxrelLF{\Gamma,A}{\Rshift{R}}{\Rext{S}}{\Psi,a} & &\tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies \tmctxrelLF{\Gamma\subst{\shift}}{\Rext{R}}{\Rshift{S}}{\Psi,\Prp}\tag*{\qedsymbol}
  \end{align*}
\end{fact}
\begin{lemma}
  The term relation $\tmr^R_S$ is total from right to left and preserves typing:
  \begin{align*}
    \typingL{\Psi}{b}{\Prp} \implies \typingL{\Psi}{a}{b} \implies &\mAll{R\,S\,N\,\Gamma} R\ms\ms\mathsf{inj} \implies \tyctxrelLF{N}{R}{\Psi} \implies \tmctxrelLF{\Gamma}{R}{S}{\Psi} \implies \\
                                                                &\mEx{s\,A} A\,\tyr^R\,b \mAnd s\,\tmr^R_S\,a \mAnd \typingF{\cc{N}{\Gamma}}{s}{A} \mAnd \istyF{N}{A}
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on $\typingL{\Psi}{a}{b}$.
  The cases are mostly analogue to the previous result.
  Injectivity of $R$ is required for the variable case.
  Note that we need to discriminate on the sorts of product domains again (cf.\ Lemma~\ref{lem:tyr_lf_tot_pres}), here to disambiguate the unified abstractions and applications correctly.
\end{proof}

\section{Abella}
\label{sec:abella}

\begin{figure}
  \begin{center}
    \begin{mathpar}
%      \mprset{fraction={{}{\,\cdot\,}{}}}
      \inferrule*{\istyFh{A} \\ \istyFh{B}}{\istyFh{(A \to B)}} \and
      \inferrule*{\lpPi x \istyFh{x} \lpImp \istyFh{\lpApp{A}{x}}}{\istyFh{(\All{A})}} \and
      \inferrule*{\typingFh{s}{\All{B}} \\ \istyFh{A}}{\typingFh{s\,A}{\lpApp{B}{A}}} \\
      \inferrule*{\lpPi x \istyFh{x} \lpImp \typingFh{\lpApp{s}{x}}{\lpApp{A}{x}}}{\typingFh{\TyLam{s}}{\All{A}}} \and
      \inferrule*{\istyFh{A} \\ \lpPi x \typingFh{x}{A} \lpImp \typingFh{\lpApp{s}{x}}{B}}{\typingFh{\Lam A s}{A \to B}} \and
      \inferrule*{\typingFh{s}{A \to B} \\ \typingFh{t}{A}}{\typingFh{s\,t}{B}}
    \end{mathpar}
  \end{center}
  \caption{HOAS specification of F in Abella.}
  \label{fig:sys-f-abella}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{mathpar}
%      \mprset{fraction={{}{\,\cdot\,}{}}}
      \inferrule*{~}{\sortLh{\Typ}} \and
      \inferrule*{~}{\sortLh{\Prp}} \and
      \inferrule*[right=t\_ax]{~}{\typingLh{\Prp}{\Typ}} \and
      \inferrule*[right=t\_pi]{\typingLh{a}{\Prod{c}{d}} \\ \typingLh{b}{c}}{\typingLh{a\,b}{\lpApp{d}{b}}} \\
      \inferrule*[right=t\_lam]{\typingLh{a}{s} \and \sortLh{s} \and \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{b}{x}}{\Prp}}{\typingLh{\Prod{a}{b}}{\Prp}} \and
      \inferrule*[right=t\_app]{\typingLh{a}{s} \and \sortLh{s} \and  \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{c}{x}}{\Prp} \\ \lpPi x \typingLh{x}{a} \lpImp \typingLh{\lpApp{b}{x}}{\lpApp{c}{x}}}{\typingLh{\Lam{a}{b}}{\Prod{a}{c}}}
    \end{mathpar}
  \end{center}
  \caption{HOAS specification of \SysL in Abella.}
  \label{fig:sys-l-abella}
\end{figure}

Let us now consider the first of our two HOAS solutions in more detail.
Abella is a system designed around a two-level logic approach.
The lower \emph{specification level}, essentially verbatim $\lambda$Prolog, is used to encode the object languages.
For our Abella variant of F we define predicates $\istyFh{A} \OF o$ for type formation and $\typingFh{s}{A} \OF o$ for typing, where $o$ is Abella's type of $\lambda$Prolog predicates.
The Abella variant of the type system of F is given in Figure~\ref{fig:sys-f-abella}.
The binders here are again nameless, but this time due to the fact that object level binding is delegated to the binding of the specification logic.
That is in $\Lam{A}{s}$ the body $s \OF \TmF \to \TmF$ is a specification logic function.
We use $\lpApp{s}{t}$ denote the application of specification logic function $s$ to an argument $t$.

To encode \SysL we define a unary predicate $\sortLh{s} \OF o$ to recognise the sorts $s$ and the typing predicate $\typingLh{a}{b} \OF o$.
The definition of the type system is given in Figure~\ref{fig:sys-l-abella}.

In Abella, reasoning about this specifications happens at the \emph{meta level}, using the logic $\mathcal{G}$.
This reasoning logic is the intuitionistic predicative fragment for Church's simple type theory, extended with natural induction, (co)inductive predicates and, for our exposition most relevant, nominal quantification ($\nabla x . \ms s$) -- a form of universal quantification, where the bound identifier is guaranteed to be suitably fresh.

The two levels are connected as follows: whenever a $\lambda$Prolog judgement $J \OF o$ holds than it has a $\lambda$Prolog derivation, and such derivations exhibit an inductive structure.
This inductive structure is accessible in $\mathcal{G}$ with propositions of the form $\{J\}$.
More generally, the derivation of $J$ may depend on hypotheses $I_0,\ldots,I_n$.
This set of hypotheses is exposed in the form of a list $L \OF \mathsf{list}\,o$, and the embedding is written as $\{L \vdash J\}$.
At this point it is interesting to observe what happens with hypothetical ($\lpImp$) and $\mathbf{\Pi}$-quantified premises.
Consider the premise of F type formation rule for $\All A$.
Embedded in $\mathcal{G}$ it takes the form $\{L \vdash\ \lpPi x \istyFh{x} \lpImp \istyFh{\lpApp{A}{x}}\}$ which is immediately converted to $\nabla x.\ms \{L, \istyFh{x} \vdash \istyFh{\lpApp{A}{x}}\}$.
The crucial thing to note is that $L$ and $A$ are both quantified outside of the $\nabla$, hence $\mathcal{G}$ enforces that $x$ is fresh for these two quantities.
In other words $x$ really is a variable in the usual sense.
Abella usually goes a step further and opens the quantification with a fresh nominal constant $n_i$ that is syntactically distinct from other quantities in the proof state.
Let us briefly stay with this example and consider the following goal, where $n_1$ is a nominal constant:
\begin{mathpar}
  \mprset{flushleft,
    fraction={===},
    fractionaboveskip=0.5ex,
    fractionbelowskip=0.5ex}
  \inferrule*{\{L \vdash \istyFh{B}\} \\\\ \{L, \istyFh{n_1} \vdash \istyFh{\lpApp{A}{n_1}}\}}{\{L \vdash \istyFh{\lpApp{A}{B}}\}}
\end{mathpar}
The embedding of $\lambda$Prolog in $\mathcal{G}$ is equipped with generic instantiation and cut theorems that are made available to the user via specific tactics.
With these we can instantiate the second premise above to $\{L, \istyFh{B} \vdash \istyFh{\lpApp{A}{B}}\}$.
Then cutting this with the first premise yields the goal.
This generic cut tactic immediately provides substitutivity results for object languages, something that usually takes a significant amount of work in low-level representations like de Bruijn.

There is one aspect of the embedding that is prone to cause headaches, namely the treatment of contexts.
Contexts are made available as lists of judgements of type $o$, but there is nothing that a priori guarantees that some $I_k \in L$ actually is of the form $\istyFh A$ for some $A$.
Moreover, since these context should represent typing contexts (or type formation contexts) they should only really contain assumptions about variables.
And variables of the object language appear in $\mathcal{G}$ as nominal constants.
So the $L$ in $\{L \vdash \istyFh{A}\}$ should be of the form
\begin{align*}
  \istyFh{n_i}, \istyFh{n_j}, \istyFh{n_k}, \ldots
\end{align*}
Meanwhile, for the derivation of a typing judgement $\{L \vdash \typingFh{s}{A}\}$, the elements of $L$ should only of the form $\istyFh{n_i}$ or $\typingFh{n_k}{A}$ (where $A$ is well-formed).
We can achieve this with an inductive $\mathcal{G}$-predicate that ensures the well-formedness of a F-typing context:
\newcommand{\ac}[3]{\ensuremath{\mathbb{C}_{#1}^{#2}\ms (#3)}}
\newcommand{\acFty}[1]{\ac{F}{\ty}{#1}}
\newcommand{\acFtm}[1]{\ac{F}{\tm}{#1}}
\begin{mathpar}
  \inferrule*{~}{\acFtm{\emptyctx}} \and
  \inferrule*{\acFtm{L} \\ x \notin L}{\acFtm{L,\istyFh{x}}}\and
  \inferrule*{\acFtm{L} \\ \{L \vdash \istyFh{A}\} \\ x \notin L,A}{\acFtm{L,\typingFh{x}{A}}}
\end{mathpar}
In Abella, the freshness assumptions are enforced through nominal quantification:
\begin{align*}
  &\mathbf{Define}\ms\ms\mathsf{ctxftm} \OF \mathsf{list}\,o \to \Prop \ms\ms\mathbf{by}\\
  &\quad\mathsf{ctxftm}\ms\emptyctx\ms;\\
  &\quad\nabla x. \ms \mathsf{ctxftm}\ms (\istyFh{x} \mathbin{::} L) \eqdef \mathsf{ctxftm}\ms L \ms;\\
  &\quad\nabla x. \ms \mathsf{ctxftm}\ms (\typingFh{x}{A} \mathbin{::} L) \eqdef \mathsf{ctxftm}\ms L \mAnd \{L \vdash \istyFh{A}\}\ms.
\end{align*}
Here $L$ and $A$ are by convention implicitly universally quantified at the outermost level of each rule, that is in particular before the $\nabla x$.
Hence $x$ is fresh for $L$ and $A$ by the nominal axioms of $\mathcal{G}$.
The definition for type formation contexts, \acFty{-}, is even simpler.

Each type in $\mathcal{G}$ is inhabited by a countably infinite number of nominal constants, which are syntactically distinct from each other and all other inhabitants of the respective type.
This allows us to formulate inversion lemmas of the following form:
\begin{align*}
  \acFty{L} \implies \{L \vdash \istyFh{A \to B}\} \implies \{L \vdash \istyFh{A}\} \mAnd \{L \vdash \istyFh{B}\}
\end{align*}
In particular this rules out the case $\istyFh{A \to B} \in L$ which could very well happen without the additional context predicate.
A large part of our present proof relies on formulating the right predicates to suitably constrain contexts, together with appropriate inversion lemmas.
There appears to be some work on automatically generating this infrastructure for basic cases as it is mostly mechanical (CITE LFMTP'14 paper here).
In the following we will have to go a step further and not only require certain contexts to be well-formed for their respective judgements but also to stand in a certain correspondence to other contexts.
Formulating the correct context relation predicates constitutes the heart of the Abella proof presented here.

So let us now look at the actual Abella solution to the equivalence challenge.
We define $\tyr$ and $\tmr$ as follows:\label{rel-rules}
\begin{mathpar}
  \inferrule*[right=r\_arr]{A \tyr a \\ \lpPi {x} B \tyr \lpApp{b}{x}}{A \to B \tyr \Prod a b} \and
  \inferrule*[right=r\_all]{\lpPi{x y} x \tyr y \lpImp \lpApp{A}{x} \tyr \lpApp{a}{y}}{\All A \tyr \Prod \Prp a}\\
  \inferrule*[right=r\_app]{s \tmr a \\ t \tmr b}{s\,t \tmr a\,b} \and
  \inferrule*[right=r\_App]{s \tmr a \\ A \tyr b}{s\,A \tmr a\,b}\\
  \inferrule*[right=r\_lam]{A \tyr a \\ \lpPi{x y} x \tmr y \lpImp \lpApp{s}{x} \tmr \lpApp{b}{y}}{\Lam A s \tmr \Lam a b} \and
  \inferrule*[right=r\_Lam]{\lpPi{x y} x \tyr y \lpImp \lpApp{s}{x} \tmr \lpApp{a}{y}}{\TyLam s \tmr \Lam \Prp a}
\end{mathpar}
Note that the techniques used to define these relations are very similar to those used to define the two type systems.
Also note that in contrast to the definition in Coq, no extra parameters/contexts are required to deal with the variable cases, which are themselves implicitly handled via the backchanining rules of the $\lambda$Prolog embedding.
The correct notion of well-formed contexts for these relations, $\ac{\tmr}{~}{-}$, simply consists of pairs of nominals that are either related as types or as terms.
Thus $\ac{\tmr}{~}{L}$ encodes the same information in Abella that was in Coq represented by the two auxiliary variable relations $S$ and $R$.
We do not explicitly define $\ac{\tyr}{~}{-}$ and instead prove the following strengthening result, which holds since derivations of a type relation cannot depend on assumptions about term variables being related.
\begin{align*}
  \ac{\tmr}{~}{L} \implies \{L, x \tmr y \vdash A \tyr a \} \implies \{L \vdash A \tyr a \}
\end{align*}
At this point it is relatively easy to prove that $\tyr$ and $\tmr$ have disjoint ranges and that each is injective and functional.
Apart from several inversion lemmas with respect to context extraction, similar to the one outlined above, the key ingredient for each proof is to show that the employed context $\ac{\tmr}{~}{L}$ already satisfies the respective property.
This in turn is a consequence of the fact that $L$ only contains pairs of related nominals which are, in particular, suitably fresh.

When it comes to the totality and preservation statements, things become more interesting.
Let us consider a first attempt of formulating left totality of $\tyr$ and the preservation of type formation from F to \SysL:
\begin{align*}
  \{L_{F} \vdash \istyFh{A}\} \implies \mEx{a} \{ L_{\tmr} \vdash A \tyr a \} \mAnd \{L_{\lambda} \vdash \typingLh{a}{\Prp}\}
\end{align*}
We will eventually prove the desired result by induction on $\{L_{F} \vdash \istyFh{A}\}$ and it will become quickly apparent that we have to enforce well-formedness of the contexts.
It is however insufficient to simply assume that each of the three contexts is locally well-formed.
While this would ensure that the contexts only contain information about variables (that is only contain nominal assumptions) it misses one key insight: the free variables in $L_{F}$ and those in $L_{\lambda}$ should be associated according to $L_{\tmr}$.
The solution to this is to define a single ternary inductive context predicate that establishes the correspondence.
The freshness assumptions are implemented again with $\nabla$.
\newcommand{\acR}[3]{\ac{R}{~}{#1 \mid #2 \mid #3}}
\begin{mathpar}
  \inferrule*{~}{\acR{\emptyctx}{\emptyctx}{\emptyctx}} \and
  \inferrule*{\acR{L_{F}}{L_{\tmr}}{L_{\lambda}} \\ x, y \notin L_{i}}{\acR{L_{F}, \istyFh{x}}{L_{\tmr}, x \tyr y}{L_{\lambda}, \typingLh{y}{\Prp}}} \and
  \inferrule*{\acR{L_{F}}{L_{\tmr}}{L_{\lambda}} \\ x, y \notin L_{i},A,a \\\\ \{L_{F} \vdash \istyFh{A}\} \\ \{ L_{\tmr} \vdash A \tyr a \} \\ \{L_{\lambda} \vdash \typingLh{a}{\Prp}\}}{\acR{L_{F}, \typingFh{x}{A}}{L_{\tmr}, x \tmr y}{L_{\lambda}, \typingLh{y}{a}}}
\end{mathpar}
It should be clear that $\acR{L_{F}}{L_{\tmr}}{L_{\lambda}}$ entails the local well-formedness of each $L_i$.
Next we establish inversion lemmas that yield for any $J \in L_i$ both the structure of $J$, including the fact that we deal with a nominal, as well as the corresponding $J'$ and $J''$ in the two other contexts.
So to obtain our result we prove the following generalisation and use the outlined inversion principle to handle the variable case:
\begin{align*}
  \{L_{F} \vdash \istyFh{A}\} \implies \mAll{L_{\tmr}L_{\lambda}} \acR{L_{F}}{L_{\tmr}}{L_{\lambda}} \implies \mEx{a} \{ L_{\tmr} \vdash A \tyr a \} \mAnd \{L_{\lambda} \vdash \typingLh{a}{\Prp}\}
\end{align*}
The result for closed judgements and empty contexts is a trivial corollary:
\begin{align*}
  \{\istyFh{A}\} \implies \mEx{a} \{ A \tyr a \} \mAnd \{\typingLh{a}{\Prp}\}
\end{align*}
The $a$ is unique due to functionality of $\tyr$.

The other three equivalences can be obtained with the same ternary predicate.
The usual pattern of first proving results about type-formation and then using them to establish the corresponding results for typing reappears.
It is also again the case that propagation (for both F and \SysL) plays a major role, as well as the degeneracy of the sort $\Typ$.
For the HOAS syntaxes and type systems, however, these properties are relatively easy to obtain.

\section{Beluga}
\label{sec:beluga}
\input{beluga.tex}

\section{Discussion and Observations}
\label{sec:disc-observ}

When we have to construct a proof for an intricate result, we are often tempted to just grab our favourite proof assistant and start hacking away.
While the approach may, with sufficient expertise, lead to a technically correct proof it is often the case that the end product does not reveal much more about the problem than ``the result holds''.
If we allow ourselves a moment of philosophical musing than we may recall that it is often claimed that the main purpose of a proof is to communicate, and convince, someone else that a certain fact follows from mutually accepted assumptions.
In this regard, all we have achieved so far is to convince some machine of such a fact.
In order to communicate the result to our colleagues as well, we usually need more than just a proof script or proof term -- we need intuitions.


\section{Conclusion and Outlook}
\label{sec:conclusion}

Suggestions and Observations:
\begin{itemize}
\item HOAS should really be understood as a high level abstraction layer, then either a system supports it directly, or it has an underlying implementation of this abstraction, e.g.\ via de Bruijn with parallel substitutions (see HYBRID for Coq).
\end{itemize}



\subsection{Future Work}
\label{sec:future-work}

The results and observations obtained here are already interesting in their own right.
As a benchmark, however, they are only of a preliminary nature.
Thus we would like to extend the present work in at least two directions.

Firstly we would like to cover additional frameworks in order to see how well these are able to handle the present challenge.
Those of immediate interest are the so-called locally nameless techniques~\cite{DBLP:conf/popl/AydemirCPPW08} and the HYBRID framework~\cite{Capretta2007, Capretta2009, DBLP:journals/jar/FeltyM12}.
The locally nameless approach provides an abstraction layer that can be seen as sitting between the pure and low-level de Bruijn approach on the one hand and the high-level HOAS approach on the other.
The HYBRID framework for Coq, on the other hand, is in spirit very close to Abella and provides a HOAS layer for Coq.
It does, however, lack Abella's $\nabla$ and neither is it equipped with Beluga's capabilities of fine-grained contextual reasoning, so it remains to be seen if the framework is capable of dealing with our benchmark.
Should it turn out that HYBRID is not (yet) up to the task, then our benchmark could act as a useful guideline for future development.

The other direction we would like to focus on concerns the benchmark itself.
At the moment, we only look at the equivalence of the typability problem.
Note, however, that we are dealing with computational systems, and as such their reduction behaviours are at least as interesting as their typability problems.
Equi-reducebility will likely present its own set of challenges, as the PTS has many more $\beta$-redices, at least prior to typing.
And reduction is of course usually defined independent of typing.

Finally it would be interesting to formulate the whole setup not only for System~F, but also for the simply typed $\lambda$-calculus on the one hand and F$_\omega$ on the other.
For the remaining corners of Barendregt's $\lambda$-cube, like for example the calculus of constructions, no corresponding two-sorted variants exist.
It is thus unclear what a suitable benchmark would look like.


% \subparagraph*{Acknowledgements.}

% I want to thank \dots

% \appendix
% \section{FOO}

% Needed?



%%
%% Bibliography
%%

 \bibliography{ref,bp-extract}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
